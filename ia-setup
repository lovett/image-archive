#!/usr/bin/env rakudo

use Config::INI;
use DBIish;
use Terminal::ANSIColor;

our IO::Path constant CONFIG_FILE = $*HOME.add(".config/ia.conf");
our Str constant SCRIPT_VERSION = "2020.10.15";

#| Establish the application config and database.
multi sub MAIN(Str $directory where *.IO.d) {
    writeStarterConfig($directory.IO);

    MAIN('completion');
    MAIN('database');
}

#| Update the shell completion file.
multi sub MAIN('completion') {
    my %config = Config::INI::parse(slurp CONFIG_FILE);
    writeShellCompletion(%config);
}

#| Update the database schema.
multi sub MAIN('database') {
    my %config = Config::INI::parse(slurp CONFIG_FILE);
    my $dbPath = %config<_><root>.IO.add("ia.db");
    defineDatabaseSchema($dbPath);
}

#| Display version information.
multi sub MAIN(Bool :$version) {
    if ($version) {
        say SCRIPT_VERSION;
        return;
    }

    say $*USAGE;
}

# Define the SQLite database used for full-text search.
sub defineDatabaseSchema($dbPath) {
    my $dbh = DBIish.connect("SQLite", database => $dbPath);

    # Tables
    # --------------------------------------------------------------------
    $dbh.execute(q:to/STATEMENT/);
    CREATE TABLE IF NOT EXISTS history (
        id INTEGER PRIMARY KEY,
        key TEXT,
        value TEXT
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TABLE IF NOT EXISTS archive (
        id INTEGER PRIMARY KEY,
        uuid TEXT,
        tags TEXT
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    DROP TABLE IF EXISTS archive_fts
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE VIRTUAL TABLE archive_fts USING fts5(
        tags, content=archive, content_rowid=id,
        tokenize='porter unicode61'
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    INSERT INTO archive_fts(rowid, tags) SELECT id, tags from archive
    STATEMENT

    # Indexes
    # --------------------------------------------------------------------
    $dbh.execute(q:to/STATEMENT/);
    CREATE INDEX IF NOT EXISTS history_key
    ON history(key)
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE UNIQUE INDEX IF NOT EXISTS archive_uuid
    ON archive(uuid)
    STATEMENT

    # Triggers
    # --------------------------------------------------------------------
    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS archive_after_insert
    AFTER INSERT ON archive
    BEGIN
    INSERT INTO archive_fts(rowid, tags) VALUES (new.id, new.tags);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS archive_after_delete
    AFTER DELETE ON archive
    BEGIN
    INSERT INTO archive_fts(archive_fts, rowid, tags) VALUES('delete', old.id, old.tags);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS archive_after_update
    AFTER UPDATE ON archive
    BEGIN
    INSERT INTO archive_fts(archive_fts, rowid, tags) VALUES('delete', old.id, old.tags);
    INSERT INTO archive_fts(rowid, tags) VALUES (new.id, new.tags);
    END
    STATEMENT

    $dbh.dispose;
}

sub writeShellCompletion(%config) {
    my $keywords = ($_ unless $_ ~~ any <_ aliases prompts contexts> for %config.keys) (|) ('no' ~ $_ for %config<contexts>.keys);

    given %*ENV<SHELL>.IO.basename {

        when "fish" {
            my $completionFile = $*HOME.add(".config/fish/completions/ia.fish");

            my $prefix = "complete -c {$*PROGRAM-NAME.IO.basename}";

            unless ($completionFile.parent.d) {
                mkdir($completionFile.parent);
            }

            spurt $completionFile, qq:to/END/;
            # This file was autogenerated by {$*PROGRAM-NAME.IO.absolute} version {SCRIPT_VERSION}

            {$prefix} --no-files --long-option=dryrun
            {$prefix} --no-files --long-option=help
            {$prefix} --no-files --long-option=version

            {$prefix} --arguments=completion

            {$prefix} --arguments=count
            {$prefix} --arguments=dbshell

            {$prefix} --arguments=deport
            {$prefix} --condition="__fish_seen_subcommand_from deport" --arguments="(__fish_complete_subcommand)"

            {$prefix} --arguments=import
            {$prefix} --condition="__fish_seen_subcommand_from import" --arguments="(__fish_complete_subcommand)"

            {$prefix} --arguments=reprompt
            {$prefix} --condition="__fish_seen_subcommand_from reprompt" --arguments="(__fish_complete_subcommand)"

            {$prefix} --arguments=search

            {$prefix} --arguments=setup
            {$prefix} --condition="__fish_seen_subcommand_from setup" --arguments="(__fish_complete_subcommand)"

            {$prefix} --arguments=stats

            {$prefix} --arguments=tag
            {$prefix} --condition="__fish_seen_subcommand_from tag" --arguments="(__fish_complete_path) {$keywords.keys.sort.join(' ')}"

            {$prefix} --arguments=trash
            {$prefix} --condition="__fish_seen_subcommand_from trash" --arguments="(__fish_complete_subcommand)"

            {$prefix} --arguments=untag
            {$prefix} --condition="__fish_seen_subcommand_from untag" --arguments="(__fish_complete_path) {%config<aliases>.keys.sort.join(' ')} {$keywords.keys.sort.join(' ')}"

            {$prefix} --arguments=view
            {$prefix} --condition="__fish_seen_subcommand_from view" --arguments="(__fish_complete_path) {%config<aliases>.keys.sort.join(' ')}"
            END

            say "Wrote $completionFile"
        }

        default {
            note colored("Sorry, shell completion isn't available for your shell", "yellow bold");
        }
    }
}

# Create a config file based on a default template.
sub writeStarterConfig(IO::Path $root) {
    if CONFIG_FILE.f {
        say "The file {CONFIG_FILE} already exists, so it was left untouched.";
        return;
    }

    spurt CONFIG_FILE, qq:to/END/;
    ; This is the configuration file for image-archive (ia)
    ; It uses the INI file format.
    ;
    ; After making changes to this file, regenerate the shell completion
    ; file by running: ia-setup completion

    ; Where the images are stored.
    root = {$root.absolute}

    ; The size presets for alternate image generation, specified as
    ; a space-separated list of GraphicsMagic geometry values.
    alt_sizes = 1000x 500x

    ; The file format for alternate image generation.
    alt_format = jpg

    ; The command to run when viewing an image.
    view_command = open -a Preview.app

    ; Questions that should be asked during tagging. They are the opposite
    ; of keywords.
    ;
    ; Use this to gather tag information that varies from file to file.
    ; Keys are aliases and values are the question text.
    [prompts]
    datecreated = Date the picture was taken (YYYY-MM-DD or partial)
    caption     = Caption
    keyword     = Additional keywords
    series      = Series or batch
    seriesid    = ID within series

    ; Aliases for tag names.
    ;
    ; Since tag names are verbose and akward to type, map them to more friendly
    ; equivalents. Keys are the informal name and values are the formal counterpart.
    [aliases]
    alias       = XMP-photoshop:SupplementalCategories
    author      = XMP-xmp:Author
    caption     = XMP-xmp:Description
    colormode   = XMP-photoshop:ColorMode
    datecreated = XMP-xmp:CreateDate
    datetagged  = XMP-xmp:MetadataDate
    id          = XMP-dc:Identifier
    location    = XMP-iptcExt:LocationCreated
    model       = Model
    object      = ArtworkOrObject
    person      = XMP-iptcExt:PersonInImage
    keyword     = XMP-dc:subject
    scene       = XMP-iptcCore:Scene
    series      = XMP-iptcExt:SeriesName
    seriesid    = XMP-iptcExt:SeriesIdentifier
    sourcetype  = XMP-iptcExt:DigitalSourceType
    subjectcode = XMP-iptcCore:SubjectCode

    ; Filters
    ;
    ; Similar to aliases, this section maps tag names to more friendly
    ; equivalents for narrowing the scope of a search. Keys are the
    ; informal name and values are the formal counterpart without any tag
    ; family prefix.

    [filters]
    alias = SupplementalCategories
    author = Author
    caption = Description
    city = City
    country = CountryName
    created = CreateDate
    event = Event
    keyword = Subject
    location = LocationName
    object = AOContentDescription
    person = PersonInImage
    series = SeriesName
    seriesid = SeriesIdentifier
    source = DigitalSourceType
    state = ProvinceState
    tagged = MetadataDate

    ; Contexts
    ;
    ; A context is a list of comma-separated tag aliases or keywords. They
    ; are a way of enforcing comprehensive tagging by requiring at least one
    ; item from each list to be present.

    [contexts]
    author = author
    count = single, two, group
    location = location
    object = object
    people = person
    relationship = family, marriage, parentchild
    scene = scene
    setting = interiorview, exteriorview
    source = model, sourcetype, colormode

    ; Keywords
    ;
    ; The rest of this file defines tagging keywords. The keyword is the
    ; section name, the keys are aliases, and the values are what will be
    ; ulatimatley be written to the image.
    ;
    ;
    ; Keywords are for applying the same tag value to multiple files, both
    ; for convenience and consistency. They are the opposite of prompts.

    ;; Color mode keywords
    ;; See https://exiftool.org/TagNames/XMP.html#photoshop
    [blackandwhite]
    colormode = Grayscale

    [color]
    colormode = RGB

    ;; Source type keywords
    ;; See http://cv.iptc.org/newscodes/digitalsourcetype/
    [digital]
    sourcetype = digitalCapture

    [negative]
    sourcetype = negativeFilm

    [slide]
    sourcetype = positiveFilm
    keyword = slide

    [photo]
    sourcetype = print

    [software]
    sourcetype = softwareImage

    ;; Scene keywords
    ;; See http://cv.iptc.org/newscodes/scene
    [action]
    scene = 011900

    [aerialview]
    scene = 011200

    [closeup]
    scene = 011800

    [couple]
    scene = 010700

    [exteriorview]
    scene = 011600

    [fulllength]
    scene = 010300

    [generalview]
    scene = 011000

    [group]
    scene = 010900

    [halflength]
    scene = 010200

    [headshot]
    scene = 010100

    [interiorview]
    scene = 011700

    [nightscene]
    scene = 011400

    [offbeat]
    scene = 012300

    [panoramicview]
    scene = 011100

    [performing]
    scene = 012000

    [posing]
    scene = 012100

    [profile]
    scene = 010400

    [rearview]
    scene = 010500

    [satellite]
    scene = 011500

    [single]
    scene = 010600

    [symbolic]
    scene = 012200

    [two]
    scene = 010800

    [underwater]
    scene = 011300

    ; ---- End of the default keyword set ----

    END

    say "Default configuration written to {CONFIG_FILE}";
    say "Using {$root.absolute} as the archive root.";
}
