#!/usr/bin/env rakudo

use Config::INI;
use DBIish;
use Terminal::ANSIColor;

our enum Command <completion dbshell deport import setup tag trash>;
our enum Mode <normal dryrun>;

our Str constant SCRIPT_VERSION = "2020.08";

our IO::Path constant CONFIG_FILE = $*HOME.add(".config/ia.conf");

our %config;

our $operatingMode = normal;

if CONFIG_FILE.e {
    readConfig();
}

# Exceptions
# ------------------------------------------------------------------------

# Custom exception thrown when an unknown command is used.
class X::ImageArchive::BadCommand is Exception {
    method message() {
        "Unexpected command. Cannot proceed.";
    }
}

# Custom exception thrown when an unknown keyword is used.
class X::ImageArchive::BadKeyword is Exception {
    has Set $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "keyword" !! "keywords";
        "Invalid {$label}: {$!offenders.keys.join(', ')}";
    }
}

# Custom exception thrown when a context exists but no keywords reference it.
class X::ImageArchive::EmptyContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context has" !! "contexts have";
        "The following {$label} no keywords: {$!offenders.join(', ')}";
    }
}

# Custom exception thrown when an exiftool call exits nonzero or writes to stderr.
class X::ImageArchive::ExifToolIsDispleased is Exception {
    has Str $.err;

    method message {
        $!err;
    }
}

# Custom exception thrown when a destination path already exists.
class X::ImageArchive::FileExists is Exception {
    has IO $.path;
    method message {
        "The file {$!path} already exists.";
    }
}

# Custom exception thrown during deport when a target file is not found.
class X::ImageArchive::FileNotFoundInArchive is Exception {
    method message {
        "No such file found under {%config<_><root>}";
    }
}

# Custom exception thrown when no keywords are provided for a context.
class X::ImageArchive::MissingContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context" !! "contexts";
        "Keywords are missing for {$!offenders.elems} {$label}: {$!offenders.join(', ')}";
    }

    method suggest {
        my %contexts = $!offenders.list Z=> %config<contexts>{$!offenders.list};

        say "";

        for %contexts.kv -> $context, $aliases {
            my @keywords = keywordsInContext($context);
            say colored("{$context} keywords", 'cyan') ~ "\n" ~ @keywords.sort.join(", ");
            say "to disable: " ~ colored("no{$context}", 'yellow') ~ "\n"
        }
    }
}

# Custom exception thrown if trash command cannot be identified.
class X::ImageArchive::TrashPathNotFound is Exception {
    method message {
        "Cannot locate Trash folder.";
    }
}

# Custom exception thrown when a UUID cannot be created.
class X::ImageArchive::UUID is Exception {
    method message {
        "Unable to generate a unique id.";
    }
}

# Entry points
# ------------------------------------------------------------------------

# Entry point for --version flag.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

# Entry point for commands that take no arguments.
multi sub MAIN(Command $command) {
    given $command {
        when completion {
            writeShellCompletion();
        }

        when dbshell {
            invokeSqlite();
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }
}

# Entry point for commands dealing with directories.
multi sub MAIN(Command $command, Str $directory where *.IO.d) {
    given $command {
        when setup {
            writeStarterConfig($directory.IO);
            readConfig();
            defineDatabaseSchema();
            writeShellCompletion();
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }
}

# Entry point for commands dealing with files.
multi sub MAIN(Command $command, Str $file where *.IO.f, Bool :$dryrun = False) {
    setOperatingMode($dryrun);

    given $command {
        when deport {
            deportFile($file.IO, $*CWD.IO);
        }

        when import {
            my $tagValue = readTag($file.IO, 'datecreated');
            if (!$tagValue) {
                my Str $answer = prompt "No date tag found. Still continue? [y/N]: ";
                unless ($answer eq "y") {
                    exit;
                }

                $tagValue = "undated";
            }

            my $destinationDir = %config<_><root>.IO.add($tagValue.subst(":", "/", :g));

            importFile($file.IO, $destinationDir);
        }

        when trash {
            my $trashFolder = findTrashFolder();
            deportFile($file.IO, $trashFolder);
        }

        CATCH {
            my @usualSuspects = (
                X::ImageArchive::FileExists,
                X::ImageArchive::FileNotFoundInArchive,
                X::ImageArchive::TrashPathNotFound
            );

            if ($_ ~~ any @usualSuspects) {
                note colored($_.message, 'red bold');
                exit 1;
            }
        }
    }
}

# Entry point for commands dealing with files and keywords.
multi sub MAIN(Command $command, Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    setOperatingMode($dryrun);

    given $command {
        when tag {
            testKeywords(@keywords);

            my @contexts = activeContexts(@keywords);

            testContexts(@contexts);

            testContextCoverage(@contexts, @keywords);

            my %tags = keywordsToTags(@keywords);
            %tags.append(askQuestions());

            tagFile($file.IO, %tags, @keywords);
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }

    CATCH {
        my @usualSuspects = (
            X::ImageArchive::BadCommand,
            X::ImageArchive::EmptyContext,
            X::ImageArchive::BadKeyword,
        );

        if ($_ ~~ any @usualSuspects) {
            note colored($_.message, 'red bold');
            exit 1;
        }

        when X::ImageArchive::MissingContext {
            note colored($_.message, 'red bold');
            $_.suggest();
            exit 1;
        }

        when X::ImageArchive::ExifToolIsDispleased {
            note colored($_.message, 'red bold');
            exit 1;
        }
    }
}

# Internal functions
# ------------------------------------------------------------------------

# List the contexts that have not been explicity disabled by a
# negation keyword.
sub activeContexts(@keywords) {
    my @keywordsWithoutNegation = @keywords.map({ $_.subst(/^no/, '')});
    (%config<contexts>.keys (-) @keywordsWithoutNegation).keys;
}

# Prompt for tag values that are unique to the image.
sub askQuestions() {
    my %answers;

    for %config<prompts>.sort(*.key) {
        my $answer = prompt "{$_.value}: ";
        $answer .= trim;
        next unless $answer;
        %answers{$_.key} = ($_.trim for $answer.split(','))
    }

    return %answers;
}

# Convert a comma-delimited list of values to a list.
sub commaSplit(Str $value) {
    $value.split(/ \s* \, \s* /);
}

# Determine the set of negation keywords for all known contexts.
# A negation keyword is the name of a context prefixed with "no".
sub contextNegationKeywords() {
    %config<contexts>.keys.map({ "no" ~ $_ });
}

# Define the SQLite database used for full-text search.
sub defineDatabaseSchema() {
    my $dbh = openDatabase();

    $dbh.execute(q:to/STATEMENT/);
    CREATE TABLE IF NOT EXISTS metadata (
        id INTEGER PRIMARY KEY,
        uuid TEXT,
        path TEXT,
        tags TEXT
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE UNIQUE INDEX IF NOT EXISTS metadata_uuid
    ON metadata(uuid)
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE VIRTUAL TABLE IF NOT EXISTS fts USING fts5(
        tags, content=metadata, content_rowid=id
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadata_after_insert
    AFTER INSERT ON metadata
    BEGIN
    INSERT INTO fts(rowid, tags) VALUES (new.id, new.tags);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadata_after_delete
    AFTER DELETE ON metadata
    BEGIN
    INSERT INTO fts(fts, rowid, tags) VALUES('delete', old.id, old.tags);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadata_after_update
    AFTER UPDATE ON metadata
    BEGIN
    INSERT INTO fts(fts, rowid, tags) VALUES('delete', old.id, old.tags);
    INSERT INTO fts(rowid, tags) VALUES (new.id, new.tags);
    END
    STATEMENT

    $dbh.dispose;
}

# Remove a file from the archive.
sub deportFile(IO $file, IO $parent) {
    testFileExistsInArchive($file);

    my $destination = $parent.add($file.basename);


    if ($destination.IO ~~ :f) {
        my Str $answer = prompt "Overwrite the existing file at {$destination} [y/N]: ";
        unless ($answer eq "y") {
            exit;
        }
    }

    given $operatingMode {
        when dryrun {
            wouldHaveDone("Remove {$file} from the database.");
            wouldHaveDone("Move {$file} to {$destination}");
            wouldHaveDone("Chmod {$destination} to read-write");
        }

        default {
            deindexFile($file);
            move($file, $destination);
            $destination.IO.chmod(0o600);
        }
    }
}

# Remove a file from the database.
sub deindexFile(IO $file) {
    my $uuid = readTag($file, 'id');
    my $rootRelativePath = $file.relative(%config<_><root>);

    my $dbh = openDatabase();
    my $sth = $dbh.prepare(q:to/STATEMENT/);
    DELETE FROM metadata WHERE uuid=? OR path=?
    STATEMENT

    $sth.execute($uuid, $rootRelativePath);
    $dbh.dispose;
}

# Figure
sub findTrashFolder() {
    my @candidates = [
        $*HOME.add(".Trash"),
        $*HOME.add(".local/share/Trash")
    ];

    for @candidates -> $candidate {
        next unless $candidate.d;
        return $candidate;
    }

    die X::ImageArchive::TrashPathFound.new();
}

# Create a new UUID using external utilities.
sub generateUuid() {
    my @generators = </proc/sys/kernel/random/uuid /usr/bin/uuidgen>;

    for @generators -> $generator {
        next unless ($generator.IO.f);

        my $proc = run $generator, :out, :err;
        my $id = $proc.out.slurp(:close);

        if ($proc.exitcode == 0) {
            return chomp($id);
        }
    }

    die X::ImageArchive::UUID.new();
}

# Return the filesystem path of the database.
sub getDatabasePath() {
    return %config<_><root>.IO.add("ia.db");
}

# Store a file's tags in a database.
sub indexFile(IO $file) {
    my $uuid = readTag($file, 'id');
    my $rootRelativePath = $file.relative(%config<_><root>);
    my $proc = run <exiftool -x File:Directory -x File:FilePermissions -j -g -struct>, $file.Str, :out, :err;
    my Str $json = chomp($proc.out.slurp(:close));
    my $err  = $proc.err.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
    }

    # Exiftool generates a JSON array of one element.
    # Mangle it to just the element.
    $json ~~ s:g/ ^\[ | \]$ //;

    my $dbh = openDatabase();
    my $sth = $dbh.prepare(q:to/STATEMENT/);
    INSERT INTO metadata (uuid, path, tags)
    VALUES (?, ?, ?)
    ON CONFLICT (uuid) DO UPDATE
    SET path=excluded.path, tags=excluded.tags
    STATEMENT

    $sth.execute($uuid, $rootRelativePath, $json);
    $dbh.dispose;
}

# Start an Sqlite CLI session.
sub invokeSqlite() {
    my $dbPath = getDatabasePath();
    run 'sqlite3', $dbPath;
}

# Find all keywords referenced by a context.
#
# A context can consist of aliases or keywords.
sub keywordsInContext($context) {
    my @keywords;

    my @terms = commaSplit(%config<contexts>{$context});

    for %config.kv -> $section, %members {
        next if $section ~~ any <_ aliases prompts contexts>;

        next unless %members.keys (&) @terms or $section ~~ any @terms;
        @keywords.push($section)
    }

    return @keywords;
}

# Gather the tags that correspond to the given keywords.
sub keywordsToTags(@keywords) {
    my %tags;

    for %config.kv -> $key, %values {
        %tags.append(%values) if $key ~~ any @keywords;
    }

    return %tags;
}

# Move a file to a subfolder under the archive root.
sub importFile(IO $file, IO $parent) {
    unless ($parent ~~ :d) {
        given $operatingMode {
            when dryrun {
                wouldHaveDone("mkdir {$parent}");
            }
            default {
                $parent.mkdir();
            }
        }
    }

    my $destination = $parent.add($file.basename);

    if ($destination.IO ~~ :f) {
        die X::ImageArchive::FileExists.new(:path($destination));
    }

    given $operatingMode {
        when dryrun {
            wouldHaveDone("Move {$file} to {$destination}");
            wouldHaveDone("Chmod {$destination} to read-only");
            wouldHaveDone("Add {$destination} to the database.");
        }

        default {
            move($file, $destination);
            $destination.IO.chmod(0o400);
            indexFile($destination);
            say "Imported {$file.basename} to {$destination}";
        }
    }
}

# Open a connection to the SQLite database.
#
# Caller is responsible for disposing of the returned handle.
sub openDatabase() {
    my $dbPath = getDatabasePath();
    return DBIish.connect("SQLite", database => $dbPath);
}

# Load the application configuration file.
sub readConfig() {
    %config = Config::INI::parse(slurp CONFIG_FILE);

    for %config.keys -> $section {
        next if $section ~~ any <_ aliases prompts contexts>;

        for %config{$section}.kv -> $key, $value {

            # Unescape backslash followed by punctuation (\', \", etc).
            %config{$section}{$key} ~~ s:g/ \\ (<punct>) /$0/;

            # Serialize structs
            if ($value.contains('{')) {
                %config{$section}{$key} ~~ s:g/ (<-[ , | \s ]>)\s+ /$0\| /;
            }
        }
    }
}

# Extract a tag specified from a file.
sub readTag(IO $file, $tag) {
    my $formalTag = %config<aliases>{$tag} || $tag;

    my $proc = run <exiftool -s3 -n>, "-{$formalTag}", $file.Str, :out, :err;
    my $err = $proc.err.slurp(:close);
    my $out = $proc.out.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
    }

    return chomp($out);
}

# Discard the backup copy of a file Exiftool has modified.
#
# Equivalent to exiftool -delete_original! but handled directly.
sub removeOriginal(IO $file) {
    my $original = $file.Str ~ "_original";

    if ($original.IO.f) {
        $original.IO.unlink();
    }
}

# Recover the backup copy of a file Exiftool has modified.
#
# Equivalent to exiftool -restore_original but handled directly.
sub restoreOriginal(IO $file) {
    my $original = $file.Str ~ "_original";

    if ($original.IO.f) {
        rename($original.IO, $file);
    }
}

# Change to an alternate mode of behavior.
sub setOperatingMode($dryRun) {
    $operatingMode = ($dryRun) ?? dryrun !! normal;
}

# Apply one or more tags specified as keywords to a file.
sub tagFile(IO $file, %tags, @keywords) {
    my $uuid = readTag($file.IO, 'id');

    # Storing the aliases makes it possible to locate images based on
    # how they were tagged (as opposed to what they were tagged with).
    %tags<alias> = @keywords.sort;

    unless ($uuid) {
        %tags<id> = generateUuid();
    }

    %tags<datetagged> = DateTime.now();


    my @commands = tagsToExifTool(%tags);

    given $operatingMode {
        when dryrun {
            wouldHaveDone("exiftool {@commands} {$file}");
        }

        default {
            my $proc = run 'exiftool', @commands, $file.Str, :out, :err;

            my $err = $proc.err.slurp(:close);
            my $out = $proc.out.slurp(:close);

            if ($proc.exitcode !== 0) {
                restoreOriginal($file);
                die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
            }

            if ($err) {
                restoreOriginal($file);
                die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
            }

            removeOriginal($file);
        }
    }
}

# Convert a set of tag keywords to a list of arguments suitable exiftool.
sub tagsToExifTool(%tags) {
    my @commands;

    for %tags.keys -> $tag {
        my $formalTag = %config<aliases>{$tag};

        my $operator = "=";
        if (%tags{$tag} ~~ List) {
            for %tags{$tag}.list -> $value {
                $operator = ($value ~~ %tags{$tag}.first) ?? "=" !! "+=";
                @commands.push("-{$formalTag}{$operator}{$value}");
            }
        } else {
            @commands.push("-{$formalTag}{$operator}{%tags{$tag}}");
        }

    }

    return @commands;
}

# See if there are any contexts with no keywords.
sub testContextCoverage(@contexts, @keywords) {

    # zipwith meta operator
    # See https://rosettacode.org/wiki/Hash_from_two_arrays#Raku
    my %contexts = @contexts Z=> %config<contexts>{@contexts};

    my $bag = BagHash.new;

    for %contexts.kv -> $key, $values {
        my @terms = commaSplit($values);

        ($bag{$key}++ if @terms (&) @keywords or @keywords (&) keywordsInContext($key));
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties.elems > 0) {
        die X::ImageArchive::MissingContext.new(:offenders($empties.keys));
    }

}

# See if there are contexts with no keywords.
sub testContexts(@contexts) {
    my $bag = BagHash.new;

    for @contexts -> $context {
        ($bag{$context}++ if keywordsInContext($context));
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties) {
        die X::ImageArchive::EmptyContext.new(:offenders($empties.keys));
    }
}

# See if a file exists within the archive root.
sub testFileExistsInArchive(IO $file) {
    unless ($file.absolute.starts-with(%config<_><root>)) {
        die X::ImageArchive::FileNotFoundInArchive.new;
    }
}

# Determine if the provided keywords are valid.
sub testKeywords(@keywords) {
    my $duds = @keywords (-) %config.keys (-) contextNegationKeywords();

    if ($duds) {
        die X::ImageArchive::BadKeyword.new(:offenders($duds));
    }
}

sub writeShellCompletion() {
    my $keywords = ($_ unless $_ ~~ any <_ aliases prompts contexts> for %config.keys).join(' ');

    given %*ENV<SHELL>.IO.basename {

        when "fish" {
            my $completionFile = $*HOME.add(".config/fish/completions/ia.fish");

            unless ($completionFile.parent.d) {
                mkdir($completionFile.parent);
            }

            spurt $completionFile, qq:to/END/;
            # This file was autogenerated by the ia utility.

            complete -c ia -l help --exclusive

            complete -c ia -n __fish_use_subcommand -a completion -d "Completion command" -f
            complete -c ia -n __fish_use_subcommand -a import     -d "Import command" -F
            complete -c ia -n __fish_use_subcommand -a setup      -d "Setup command"
            complete -c ia -n __fish_use_subcommand -a tag        -d "Tag command" -F

            # The setup command takes a directory as its argument.
            complete -c ia -n "__fish_seen_subcommand_from setup" -r -f --arguments "(__fish_complete_directories (commandline -ct) 'archive root')"

            # The import command takes one or more keywords as arguments.
            complete -c ia -n "__fish_seen_subcommand_from tag" -a "{$keywords}"
            END

            say "Wrote $completionFile"
        }

        default {
            note colored("Sorry, shell completion isn't available for your shell", "yellow bold");
        }
    }
}

# Print a messsage to stdout indicating what would have happened if
# the --dryrun flag had not been specified.
sub wouldHaveDone(Str $message) {
    say colored("DRYRUN", "magenta") ~ " " ~ $message;
}


# Create a config file based on a default template.
sub writeStarterConfig(IO::Path $root) {
    if CONFIG_FILE.f {
        say "The file {CONFIG_FILE} already exists, so it was left untouched.";
        return;
    }

    spurt CONFIG_FILE, qq:to/END/;
    ; This is the configuration file for image-archive (ia)
    ; It uses the INI file format.
    ;
    ; After making changes to this file, regenerate the shell completion
    ; file by running: ia completion

    [_]
    ; Where the images are stored.
    root = {$root.absolute}

    ; Questions that should be asked during tagging. They are the opposite
    ; of keywords.
    ;
    ; Use this to gather tag information that varies from file to file.
    ; Keys are aliases and values are the question text.
    [prompts]
    datecreated = Date the picture was taken (YYYY-MM-DD or partial)
    caption     = Caption
    keyword     = Additional keywords
    series      = Series or batch
    seriesid    = ID within series

    ; Aliases for tag names.
    ;
    ; Since tag names are verbose and akward to type, map them to more friendly
    ; equivalents. Keys are the informal name and values are the formal counterpart.
    [aliases]
    alias       = XMP-photoshop:SupplementalCategories
    author      = XMP-xmp:Author
    caption     = XMP-xmp:Description
    colormode   = XMP-photoshop:ColorMode
    datecreated = XMP-xmp:CreateDate
    datetagged  = XMP-xmp:MetadataDate
    id          = XMP-dc:Identifier
    location    = XMP-iptcExt:LocationCreated
    model       = Model
    object      = ArtworkOrObject
    person      = XMP-iptcExt:PersonInImage
    keyword     = XMP-dc:subject
    scene       = XMP-iptcCore:Scene
    series      = XMP-iptcExt:SeriesName
    seriesid    = XMP-iptcExt:SeriesIdentifier
    sourcetype  = XMP-iptcExt:DigitalSourceType
    subjectcode = XMP-iptcCore:SubjectCode

    ; Contexts
    ;
    ; A context is a list of comma-separated tag aliases or keywords. They
    ; are a way of enforcing comprehensive tagging by requiring at least one
    ; item from each list to be present.

    [contexts]
    author = author
    count = single, two, group
    location = location
    object = object
    people = person
    relationship = family, marriage, parentchild
    scene = scene
    setting = interiorview, exteriorview
    source = model, sourcetype, colormode

    ; Keywords
    ;
    ; The rest of this file defines tagging keywords. The keyword is the
    ; section name, the keys are aliases, and the values are what will be
    ; ulatimatley be written to the image.
    ;
    ;
    ; Keywords are for applying the same tag value to multiple files, both
    ; for convenience and consistency. They are the opposite of prompts.

    ;; Color mode keywords
    ;; See https://exiftool.org/TagNames/XMP.html#photoshop
    [blackandwhite]
    colormode = Grayscale

    [color]
    colormode = RGB

    ;; Source type keywords
    ;; See http://cv.iptc.org/newscodes/digitalsourcetype/
    [digital]
    sourcetype = digitalCapture

    [negative]
    sourcetype = negativeFilm

    [slide]
    sourcetype = positiveFilm
    keyword = slide

    [photo]
    sourcetype = print

    [software]
    sourcetype = softwareImage

    ;; Scene keywords
    ;; See http://cv.iptc.org/newscodes/scene
    [action]
    scene = 011900

    [aerialview]
    scene = 011200

    [closeup]
    scene = 011800

    [couple]
    scene = 010700

    [exteriorview]
    scene = 011600

    [fulllength]
    scene = 010300

    [generalview]
    scene = 011000

    [group]
    scene = 010900

    [halflength]
    scene = 010200

    [headshot]
    scene = 010100

    [interiorview]
    scene = 011700

    [nightscene]
    scene = 011400

    [offbeat]
    scene = 012300

    [panoramicview]
    scene = 011100

    [performing]
    scene = 012000

    [posing]
    scene = 012100

    [profile]
    scene = 010400

    [rearview]
    scene = 010500

    [satellite]
    scene = 011500

    [single]
    scene = 010600

    [symbolic]
    scene = 012200

    [two]
    scene = 010800

    [underwater]
    scene = 011300

    ; ---- End of the default keyword set ----

    END

    say "Default configuration written to {CONFIG_FILE}";
    say "Using {$root.absolute} as the archive root.";
}
