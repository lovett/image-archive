#!/usr/bin/env rakudo

use Config::INI;
use DBIish;
#use Grammar::Tracer;
use Terminal::ANSIColor;

our enum Mode <normal dryrun>;

our Str constant SCRIPT_VERSION = "2020.10.14";

our IO::Path constant CONFIG_FILE = $*HOME.add(".config/ia.conf");

our %config;

our $operatingMode = normal;

our constant UNDATED = 'undated';

if CONFIG_FILE.e {
    readConfig();
}

# Exceptions
# ------------------------------------------------------------------------

# A search with an invalid filter.
class X::ImageArchive::BadFilter is Exception {
    method message {
        "Unknown search filter."
    }

    method suggest {
        my @filters = %config<filters>.keys.sort;

        say "";

        say colored("Search Filters", 'cyan') ~ "\n" ~ @filters.sort.join(", ");

    }
}

# An unknown keyword is used during tagging.
class X::ImageArchive::BadKeyword is Exception {
    has Set $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "keyword" !! "keywords";
        "Unknown {$label}: {$!offenders.keys.join(', ')}";
    }
}

# A tagging context without keywords.
class X::ImageArchive::EmptyContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context has" !! "contexts have";
        "The following {$label} no keywords: {$!offenders.join(', ')}";
    }
}

# An external call did not exit cleanly.
class X::ImageArchive::BadExit is Exception {
    has Str $.err;

    method message {
        $!err;
    }
}

# A file slated for import clashes with an existing file.
class X::ImageArchive::FileExists is Exception {
    has IO $.path;
    method message {
        "The file {$!path} already exists.";
    }
}

# The configuration is missing an expected value.
class X::ImageArchive::MissingConfig is Exception {
    has Str $.key;

    method message {
        "Cannot continue. No {$!key} in {CONFIG_FILE}";
    }
}

# A tagging context is not accounted for.
class X::ImageArchive::MissingContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context" !! "contexts";
        "Keywords are missing for {$!offenders.elems} {$label}: {$!offenders.join(', ')}";
    }

    method suggest {
        my %contexts = $!offenders.list Z=> %config<contexts>{$!offenders.list};

        say "";

        for %contexts.kv -> $context, $aliases {
            my @keywords = keywordsInContext($context);
            say colored("{$context} keywords", 'cyan') ~ "\n" ~ @keywords.sort.join(", ");
            say "to disable: " ~ colored("no{$context}", 'yellow') ~ "\n"
        }
    }
}

# The search command is invoked without search terms.
class X::ImageArchive::NoSearchQuery is Exception {
    method message {
        "No search terms provided."
    }
}

# A file thought to be in the archive does not exist.
class X::ImageArchive::PathNotFoundInArchive is Exception {
    method message {
        "No such path under {%config<_><root>}";
    }
}

# A UUID cannot be generated using OS-provided mechanisms.
class X::ImageArchive::UUID is Exception {
    method message {
        "Unable to generate a unique id.";
    }
}

# Grammars
# ------------------------------------------------------------------------
grammar Search {
    rule TOP {
        [ <tag> | <date> | <term> ]*
    }

    rule tag {
        $<name> = [ \w+ ] ':'
    }

    token date {
        <[ \d \- ]>+
    }

    token term {
        <[ \w \' \" \- \. ]>+
    }
}

class SearchActions {
    has $!tag = 'any';
    has %!terms;

    method tag ($/) {
        my $formalTag = %config<filters>{$/<name>};
        unless ($formalTag) {
            die X::ImageArchive::BadFilter.new;
        }

        $!tag = $formalTag;
    }

    method term ($/) {
        %!terms{$!tag}.append($/.subst(/\W/, '', :g));
    }

    method date ($/) {
        %!terms{$!tag}.append('"' ~ $/.subst(/\-/, ':', :g) ~ '"');
    }

    method TOP ($/) {
        my @clauses;
        my $distance = 10;

        my @fragments;
        for %!terms.kv -> $key, @values {
            my $phrase = @values.join(' ');
            given $key {
                when 'any' {
                    @fragments.append: $phrase;
                }

                default {
                    @fragments.append: "NEAR($key $phrase, $distance)";
                }
            }
        }

        $/.make: "SELECT rowid FROM fts WHERE fts MATCH '" ~ @fragments.join(' ') ~ "'";
    }
}

# Entry points
# ------------------------------------------------------------------------
proto MAIN(|) {
    # Suppress backtrace. Taken from zef's CLI.pm6.
    CATCH {
        default {
            try { ::("Rakudo::Internals").?LL-EXCEPTION } ?? .rethrow !! note colored(.message, 'red bold'); &*EXIT(1)
        }
    }
    {*}
}

multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

multi sub MAIN('dbshell') {
    invokeSqlite();
}

multi sub MAIN('search', *@terms) {

    my $query = @terms.join(' ');

    unless ($query) {
        die X::ImageArchive::NoSearchQuery.new;
    }

    my $counter = 0;
    for searchMetadata($query) -> $result {
        my $index = colored(sprintf("%3d", ++$counter), 'cyan');
        say " $index $result";
    }

    unless ($counter) {
        note 'No matches.';
    }

    CATCH {
        when X::ImageArchive::BadFilter {
            note colored($_.message, 'red bold');
            $_.suggest();
            exit 1;
        }
    }
}

multi sub MAIN('deport', Str $file where *.IO.f, Bool :$dryrun) {
    setOperatingMode($dryrun);
    deportFile($file.IO, $*CWD.IO);
}

multi sub MAIN('reprompt', Str $file where *.IO.f, Bool :$dryrun = False) {
    setOperatingMode($dryrun);

    my %tags = askQuestions();

    tagFile($file.IO, %tags);
}

multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    setOperatingMode($dryrun);

    my $tagValue = readTag($file.IO, 'datecreated') || UNDATED;

    my $destinationDir = %config<_><root>.IO.add($tagValue.subst(":", "/", :g));

    importFile($file.IO, $destinationDir);
}

multi sub MAIN('stats') {

    my %counts;

    my $callback = sub ($path) {
        my $topDir =  $path.split('/', 2).first;
        %counts{$topDir}++;
    }

    walkArchive($callback);

    my $fileCount = %counts.values.reduce: &infix:<+>;
    my $fileLabel = ($fileCount == 1) ?? 'file' !! 'files';

    given $fileCount {
        when 0 {
            say "Found no files.";
        }

        default {
            my $pad = UNDATED.chars + 1;
            my $format = "%{$pad}s: %{$fileCount.Str.chars}d";

            for %counts.keys.sort -> $key {
                my $total = %counts{$key};
                sprintf($format, $key, $total).say;
            }

            sprintf($format, 'TOTAL', $fileCount).say;
        }
    }

    my $recordCount = countRecords();
    my $recordLabel = ($recordCount == 1) ?? 'record' !! 'records';

    if ($recordCount !== $fileCount) {
        say "";
        note colored("The database contains $recordCount $recordLabel.", 'red');
    }
}

multi sub MAIN('trash', Str $file where *.IO.f, Bool :$dryrun = False) {
    setOperatingMode($dryrun);

    my $trashFolder = findTrashFolder();
    deportFile($file.IO, $trashFolder);
}

multi sub MAIN('tag', Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    setOperatingMode($dryrun);

    testKeywords(@keywords);

    # If the file has id and alias tags, consider it previously tagged
    # and append @keywords to what already exists.
    my $previouslyTagged = readTags($file.IO, ['id', 'alias']).elems == 2;

    my %tags = keywordsToTags(@keywords);

    unless ($previouslyTagged) {
        my @contexts = activeContexts(@keywords);

        testContexts(@contexts);

        testContextCoverage(@contexts, @keywords);

        %tags.append(askQuestions());
    }

    tagFile($file.IO, %tags, @keywords);

    CATCH {
        when X::ImageArchive::MissingContext {
            note colored($_.message, 'red bold');
            $_.suggest();
            exit 1;
        }
    }
}

#| Generate alternate image sizes.
multi sub MAIN('alts') {
    generateAlts();
}

multi sub MAIN(
    'untag',
    Str $file where *.IO.f,
    Str $alias where { %config<aliases>{$alias}:exists },
    Str $value='',
    Bool :$dryrun = False
) {
    setOperatingMode($dryrun);

    untagFile($file.IO, %($alias, $value));

    unless ($operatingMode eq dryrun) {
        my $value = readTag($file.IO, $alias);
        say $value if $value;
    }
}

multi sub MAIN(
    'untag',
    Str $file where *.IO.f,
    Bool :$dryrun = False,
    *@keywords
) {
    setOperatingMode($dryrun);

    testKeywords(@keywords);

    my %tags = keywordsToTags(@keywords);

    untagFile($file.IO, %tags, @keywords);
}

multi sub MAIN('view', Str $path) {
    my $command = %config<_><view_command>;

    unless ($command) {
        die X::ImageArchive::MissingConfig.new(:key('view_command'));
    }

    my IO::Path $target = $path.IO;

    unless ($target.absolute.starts-with(%config<_><root>)) {
        $target = %config<_><root>.IO.add($path);
    }

    my $proc = run qqw{$command $target}, :err;
    my $err = $proc.err.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::BadExit.new(:err($err));
    }
}

multi sub MAIN('dump', Str $file where *.IO.f, *@aliases) {
    unless @aliases.elems > 0 {
        @aliases = ['alias'].append: %config<prompts>.keys;
    }

    my %tags = readTags($file.IO, @aliases, '-f');

    for %tags.kv -> $alias, $value {
        say "{$alias}: {$value}";
    }
}

# Internal functions
# ------------------------------------------------------------------------

# List the contexts that have not been explicity disabled by a
# negation keyword.
sub activeContexts(@keywords) {
    my @keywordsWithoutNegation = @keywords.map({ $_.subst(/^no/, '')});
    (%config<contexts>.keys (-) @keywordsWithoutNegation).keys;
}

# Prompt for tag values that are unique to the image.
sub askQuestions() {
    my %answers;

    for %config<prompts>.sort(*.key) {
        my $answer = prompt "{$_.value}: ";
        $answer .= trim;
        next unless $answer;
        %answers{$_.key} = ($_.trim for $answer.split(','))
    }

    return %answers;
}

# Convert a comma-delimited list of values to a list.
sub commaSplit(Str $value) {
    $value.split(/ \s* \, \s* /);
}

# Ask a yes-or-no question and exit if the answer isn't yes.
sub confirm(Str $question) {
    exit unless (prompt "{$question} [y/N]: ") eq 'y';
}

# Determine the set of negation keywords for all known contexts.
# A negation keyword is the name of a context prefixed with "no".
sub contextNegationKeywords() {
    %config<contexts>.keys.map({ "no" ~ $_ });
}

# Count paths within the archive by their metadata.
sub countMetadata(Str $query) {

    my $dbh = openDatabase();

    my $sth = $dbh.execute("SELECT count(*) FROM fts
    WHERE fts MATCH ?", $query);

    my $row = $sth.row;
    $dbh.dispose;
    return $row[0];
}

# Count metadata rows in the database.
sub countRecords() {
    my $dbh = openDatabase();

    my $sth = $dbh.execute(q:to/STATEMENT/);
    SELECT count(*) FROM metadata
    STATEMENT

    my $row = $sth.row;
    $dbh.dispose;
    return $row[0];
}

# Remove a file from the archive.
sub deportFile(IO $file, IO $parent) {
    testPathExistsInArchive($file);

    my $destination = $parent.add($file.basename);

    if ($destination.IO ~~ :f) {
        confirm("Overwrite {$file.basename} in {$parent}?");
    }

    given $operatingMode {
        when dryrun {
            wouldHaveDone("Remove {$file} from the database.");
            wouldHaveDone("Move {$file} to {$destination}");
            wouldHaveDone("Chmod {$destination} to read-write");
        }

        default {
            deindexFile($file);
            move($file, $destination);
            $destination.IO.chmod(0o600);
            deleteAlts($file);
        }
    }
}

# Remove a file from the database.
sub deindexFile(IO $file) {
    my $uuid = readTag($file, 'id');
    my $rootRelativePath = $file.relative(%config<_><root>);

    my $dbh = openDatabase();
    my $sth = $dbh.prepare(q:to/STATEMENT/);
    DELETE FROM metadata WHERE uuid=? OR path=?
    STATEMENT

    $sth.execute($uuid, $rootRelativePath);
    $dbh.dispose;
}

# Figure out where to put trashed files.
sub findTrashFolder() {
    my @candidates = [
        $*HOME.add(".Trash"),
        $*HOME.add(".local/share/Trash")
    ];

    for @candidates -> $candidate {
        next unless $candidate.d;
        return $candidate;
    }

    die X::ImageArchive::TrashPathFound.new();
}

sub deleteAlts(IO::Path $file) {
    my $root = %config<_><root>;
    my $relativePath = $file.relative($root).IO;

    my $thumbnailExtension = %config<_><alt_format>;

    for %config<_><alt_sizes>.split(' ') -> $size {
        my $target = %config<_><root>.IO.add("_cache/$size/$relativePath").extension($thumbnailExtension);
        say $target;
        $target.IO.unlink;
    }
}

# Resize and thumbnail via GraphicsMagick.
#
# If a path is not given, the archive is walked.
sub generateAlts(IO::Path $file?) {
    my %rosters;
    my %counters;
    my $thumbnailExtension = %config<_><alt_format>;

    indir %config<_><root>, {
        for %config<_><alt_sizes>.split(' ') -> $size {
            %rosters{$size} = "roster-{$size}.txt".IO.open(:w);
        }

        if ($file) {
            testPathExistsInArchive($file);

            for %rosters.kv -> $size, $handle {
                $handle.say($file.relative(%config<_><root>));
                %counters{$size}++;
            }
        } else {
            my $callback = sub ($path) {
                for %rosters.kv -> $size, $handle {
                    my $target = %config<_><root>.IO.add("_cache/$size/$path").extension($thumbnailExtension);
                    next if $target ~~ :f;
                    $handle.say($path);
                    %counters{$size}++;
                }
            }

            walkArchive($callback);
        }

        for %rosters.kv -> $size, $handle {
            $handle.close;

            unless ($handle.path ~~ :z) {
                my $count = %counters{$size};
                my $label = ($count == 1) ?? 'file' !! 'files';

                unless ($file) {
                    print colored("Generating {$count} {$label } at {$size}...", 'magenta');
                }

                my $proc = run qqw{
                    gm mogrify -output-directory _cache/$size -create-directories -format $thumbnailExtension -thumbnail $size
                }, "@roster-{$size}.txt", :out, :err;
                my $err = $proc.err.slurp(:close);
                my $out = $proc.out.slurp(:close);


                if ($proc.exitcode !== 0) {
                    say $err;
                    die X::ImageArchive::BadExit.new(:err($err));
                }

                unless ($file) {
                    say "done";
                }
            }

            $handle.path.unlink;
        }
    }
}

# Create a new UUID using external utilities.
sub generateUuid() {
    my @generators = </proc/sys/kernel/random/uuid /usr/bin/uuidgen>;

    for @generators -> $generator {
        next unless ($generator.IO.f);

        if ($generator.starts-with('/proc/')) {
            my $id = $generator.IO.slurp();
            return chomp($id);
        } else {
            my $proc = run $generator, :out, :err;
            my $id = $proc.out.slurp(:close);

            if ($proc.exitcode == 0) {
                return chomp($id);
            }
        }
    }

    die X::ImageArchive::UUID.new();
}

# Return the filesystem path of the database.
sub getDatabasePath() {
    return %config<_><root>.IO.add("ia.db");
}

# Store a file's tags in a database.
sub indexFile(IO $file) {
    my $uuid = readTag($file, 'id');
    my $rootRelativePath = $file.relative(%config<_><root>);
    my $proc = run <exiftool -x File:Directory -x File:FilePermissions -j -g -struct>, $file.Str, :out, :err;
    my Str $json = chomp($proc.out.slurp(:close));
    my $err  = $proc.err.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::BadExit.new(:err($err));
    }

    # Exiftool generates a JSON array of one element.
    # Mangle it to just the element.
    $json ~~ s:g/ ^\[ | \]$ //;

    my $dbh = openDatabase();
    my $sth = $dbh.prepare(q:to/STATEMENT/);
    INSERT INTO metadata (uuid, path, tags)
    VALUES (?, ?, ?)
    ON CONFLICT (uuid) DO UPDATE
    SET path=excluded.path, tags=excluded.tags
    STATEMENT

    $sth.execute($uuid, $rootRelativePath, $json);
    $dbh.dispose;
}

# Start an Sqlite CLI session.
sub invokeSqlite() {
    my $dbPath = getDatabasePath();
    run 'sqlite3', $dbPath;
}

# Find all keywords referenced by a context.
#
# A context can consist of aliases or keywords.
sub keywordsInContext($context) {
    my @keywords;

    my @terms = commaSplit(%config<contexts>{$context});

    for %config.kv -> $section, %members {
        next if $section ~~ any <_ aliases prompts contexts>;

        next unless %members.keys (&) @terms or $section ~~ any @terms;
        @keywords.push($section)
    }

    return @keywords;
}

# Gather the tags that correspond to the given keywords.
sub keywordsToTags(@keywords) {
    my %tags;

    for %config.kv -> $key, %values {
        %tags.append(%values) if $key ~~ any @keywords;
    }

    return %tags;
}

# Move a file to a subfolder under the archive root.
sub importFile(IO $file, IO $parent) {
    unless ($parent ~~ :d) {
        given $operatingMode {
            when dryrun {
                wouldHaveDone("mkdir {$parent}");
            }
            default {
                $parent.mkdir();
            }
        }
    }

    my $destination = $parent.add($file.basename);

    if ($destination ~~ :f) {
        die X::ImageArchive::FileExists.new(:path($destination));
    }

    given $operatingMode {
        when dryrun {
            wouldHaveDone("Move {$file} to {$destination}");
            wouldHaveDone("Chmod {$destination} to read-only.");
            wouldHaveDone("Add {$destination} to the database.");
            wouldHaveDone("Generate alternate image sizes.");
        }

        default {
            my $root = %config<_><root>;
            move($file, $destination);
            $destination.IO.chmod(0o400);
            indexFile($destination);
            generateAlts($destination);
            say "Imported {$file.basename} to {$destination}";
        }
    }
}

# Open a connection to the SQLite database.
#
# Caller is responsible for disposing of the returned handle.
sub openDatabase() {
    my $dbPath = getDatabasePath();
    return DBIish.connect("SQLite", database => $dbPath);
}

# Load the application configuration file.
sub readConfig() {
    %config = Config::INI::parse(slurp CONFIG_FILE);

    my @skippableSections := <_ aliases prompts contexts>;

    my regex unescape { \\ (<punct>) };

    for %config.kv -> $section, %members {
        next if $section ∈ @skippableSections;

        for %members.kv -> $key, $value {
            # Remove backslash when followed by punctuation.
            %config{$section}{$key} = $value.subst(&unescape, { "$0" }, :g);
        }
    }
}

# Extract a tag specified from a file.
sub readTag(IO $file, $tag) {
    my $formalTag = %config<aliases>{$tag} || $tag;

    my $proc = run <exiftool -s3 -n>, "-{$formalTag}", $file.Str, :out, :err;
    my $err = $proc.err.slurp(:close);
    my $out = $proc.out.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::BadExit.new(:err($err));
    }

    return chomp($out);
}

# Extract multiple tags from a file.
sub readTags(IO $file, @tags, Str $flags = '') {
    my @formalTags;
    for @tags -> $tag {
        @formalTags.push('-' ~ (%config<aliases>{$tag} || $tag));
    }

    my $proc = run qqw{exiftool -args $flags}, @formalTags, $file.Str, :out, :err;
    my $err = $proc.err.slurp(:close);
    my $out = $proc.out.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::BadExit.new(:err($err));
    }

    my %tags;
    for $out.lines -> $line {
        my @pairs = $line.split('=');

        my $alias = tagToAlias(@pairs.first.substr(1));

        %tags{$alias} = @pairs[1];
    }

    return %tags;
}


# Discard the backup copy of a file Exiftool has modified.
#
# Equivalent to exiftool -delete_original! but handled directly.
sub removeOriginal(IO $file) {
    my $original = $file.Str ~ "_original";

    if ($original.IO.f) {
        $original.IO.unlink();
    }
}

# Recover the backup copy of a file Exiftool has modified.
#
# Equivalent to exiftool -restore_original but handled directly.
sub restoreOriginal(IO $file) {
    my $original = $file.Str ~ "_original";

    if ($original.IO.f) {
        rename($original.IO, $file);
    }
}

# Locate paths within the archive by their metadata.
sub searchMetadata(Str $query) {
    my $dbh = openDatabase();

    my $sql = Search.parse($query, actions => SearchActions.new);

    my $sth = $dbh.execute("SELECT path FROM metadata
       WHERE id IN ({$sql.made})
       ORDER BY path");

    return gather {
        for $sth.allrows() -> $row {
            take $row[0];
        }

        $dbh.dispose;
    }
}

# Change to an alternate mode of behavior.
sub setOperatingMode($dryRun) {
    $operatingMode = ($dryRun) ?? dryrun !! normal;
}

# Apply one or more tags specified as keywords to a file.
sub tagFile(IO $file, %tags, @keywords?) {
    my $uuid = readTag($file.IO, 'id');

    unless ($uuid) {
        %tags<id> = generateUuid();
    }

    # Storing the aliases makes it possible to locate images based on
    # how they were tagged (as opposed to what they were tagged with).
    if (@keywords) {
        %tags<alias> = set(readTag($file.IO, 'alias').Array.append(@keywords.sort));
    }

    %tags<datetagged> = DateTime.now();

    my @commands = tagsToExifTool(%tags);

    commitTags($file, @commands);
}

# Write one or more tags to a file via exiftool.
sub commitTags(IO $file, @commands) {
    given $operatingMode {
        when dryrun {
            wouldHaveDone("exiftool -ignoreMinorErrors {@commands} {$file}");
        }

        default {
            my $proc = run <exiftool -ignoreMinorErrors>, @commands, $file.Str, :out, :err;

            my $err = $proc.err.slurp(:close);
            my $out = $proc.out.slurp(:close);

            if ($proc.exitcode !== 0) {
                restoreOriginal($file);
                die X::ImageArchive::BadExit.new(:err($err));
            }

            if ($err) {
                restoreOriginal($file);
                die X::ImageArchive::BadExit.new(:err($err));
            }

            removeOriginal($file);
        }
    }
}

# Map a formal tag back to its corresponding alias.
sub tagToAlias(Str $tag) {
    for %config<aliases>.kv -> $alias, $formalTag {
        return $alias if $tag eq $formalTag;
        return $alias if $formalTag.ends-with($tag);
    }

    return $tag;
}

# Convert a set of tag keywords to a list of arguments suitable for exiftool.
sub tagsToExifTool(%tags) {
    my @commands;

    for %tags.keys -> $tag {
        my $formalTag = %config<aliases>{$tag};

        my $value = %tags{$tag};

        if ($value ~~ List) {
            for $value.list -> $item {
                my $operator = ($item ~~ $value.first) ?? "=" !! "+=";
                @commands.push("-{$formalTag}{$operator}{$item}");
            }
        } elsif ($value ~~ Str && $value.starts-with('-')) {
            @commands.push("-{$formalTag}-={$value.substr(1)}");
        } else {
            @commands.push("-{$formalTag}={$value}");
        }
    }

    return @commands;
}

# See if there are any contexts with no keywords.
sub testContextCoverage(@contexts, @keywords) {

    # zipwith meta operator
    # See https://rosettacode.org/wiki/Hash_from_two_arrays#Raku
    my %contexts = @contexts Z=> %config<contexts>{@contexts};

    my $bag = BagHash.new;

    for %contexts.kv -> $key, $values {
        my @terms = commaSplit($values);

        ($bag{$key}++ if @terms (&) @keywords or @keywords (&) keywordsInContext($key));
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties.elems > 0) {
        die X::ImageArchive::MissingContext.new(:offenders($empties.keys));
    }

}

# See if there are contexts with no keywords.
sub testContexts(@contexts) {
    my $bag = BagHash.new;

    for @contexts -> $context {
        ($bag{$context}++ if keywordsInContext($context));
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties) {
        die X::ImageArchive::EmptyContext.new(:offenders($empties.keys));
    }
}

# See if a file exists within the archive root.
sub testPathExistsInArchive(IO $file) {
    return if $file.absolute.starts-with(%config<_><root>) && ($file ~~ :e);
    die X::ImageArchive::PathNotFoundInArchive.new;
}

# Determine if the provided keywords are valid.
sub testKeywords(@keywords) {
    my $duds = @keywords (-) %config.keys (-) contextNegationKeywords();

    if ($duds) {
        die X::ImageArchive::BadKeyword.new(:offenders($duds));
    }
}

# Remove tag values from a file.
sub untagFile(IO $file, %tags, @keywords?) {
    if (@keywords) {
        %tags<alias> = @keywords.sort;
    }

    for %tags.kv -> $tag, $value {
        if ($value eq '') {
            next;
        }

        my $currentValue = readTag($file.IO, $tag);

        if ($currentValue eq '') {
            next;
        }

        if ($currentValue.contains('{')) {
            %tags{$tag} = '';
            next;
        }

        if ($currentValue.contains(',')) {
            %tags{$tag} = commaSplit($currentValue) (-) $value;
            next;
        }

        %tags{$tag} = $currentValue.subst($value, '').subst(/ \s+ /, ' ', :g).trim();
    }

    my @commands = tagsToExifTool(%tags);

    commitTags($file, @commands);
}

# Perform an action on each file in the archive.
sub walkArchive(Callable $callback) {
    my $root = %config<_><root>.IO;

    my @stack = $root;
    my @skipExtensions := <db bak txt>;

    while (@stack)  {
        for @stack.pop.dir -> $path {
            next if $path.IO.basename.starts-with('.');
            next if $path.IO.extension ∈ @skipExtensions;

            if ($path ~~ :d) {
                my $topDir = $path.relative($root).split('/', 2).first;
                next if $topDir eq '_cache';

                @stack.push($path);
                next;
            }


            $callback($path.relative($root));
        }
    }
}

# Print a messsage to stdout indicating what would have happened if
# the --dryrun flag had not been specified.
sub wouldHaveDone(Str $message) {
    say colored("DRYRUN", "magenta") ~ " " ~ $message;
}
