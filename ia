#!/usr/bin/env rakudo

use Config::INI;
use DBIish;
use Terminal::ANSIColor;

our enum Command <completion import setup tag>;

our Str constant SCRIPT_VERSION = "2020.08";

our IO::Path constant CONFIG_FILE = $*HOME.add(".config/ia.conf");

our %config;

if CONFIG_FILE.e {
    readConfig();
}

# Exceptions
# ------------------------------------------------------------------------

# Custom exception thrown when an unknown command is used.
class X::ImageArchive::BadCommand is Exception {
    method message() {
        "Unexpected command. Cannot proceed.";
    }
}

# Custom exception thrown when an unknown keyword is used.
class X::ImageArchive::BadKeyword is Exception {
    has Set $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "keyword" !! "keywords";
        "Invalid {$label}: {$!offenders.keys.join(', ')}";
    }
}

# Custom exception thrown when a context exists but no keywords reference it.
class X::ImageArchive::EmptyContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context has" !! "contexts have";
        "The following {$label} no keywords: {$!offenders.join(', ')}";
    }
}

# Custom exception thrown when an exiftool call exits nonzero.
class X::ImageArchive::ExifToolIsDispleased is Exception {
    has Str $.err;

    method message {
        say $!err;
    }
}

# Custom exception thrown during import when a destination already exists.
class X::ImageArchive::FileExists is Exception {
    has IO $.path;
    method message {
        my $relpath = $!path.relative(%config<_><root>);
        "A file has already been imported as {$relpath}";
    }
}

# Custom exception thrown when no keywords are provided for a context.
class X::ImageArchive::MissingContext is Exception {
    has Seq $.offenders;
    method message {
        my $label = ($!offenders.elems == 1) ?? "context" !! "contexts";
        "Keywords are missing for {$!offenders.elems} {$label}: {$!offenders.join(', ')}";
    }

    method suggest {
        my %contexts = $!offenders.list Z=> %config<contexts>{$!offenders.list};

        say "";

        for %contexts.kv -> $context, $aliases {
            my @keywords = keywordsInContext($context);
            say colored("{$context} keywords", 'cyan') ~ "\n" ~ @keywords.sort.join(", ") ~ "\n";

        }
    }
}

# Custom exception thrown when a UUID cannot be created.
class X::ImageArchive::UUID is Exception {
    method message {
        "Unable to generate a unique id.";
    }
}

# Entry points
# ------------------------------------------------------------------------

# Entry point for --version flag.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

# Entry point for commands that take no arguments.
multi sub MAIN(Command $command) {
    given $command {
        when completion {
            writeShellCompletion();
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }
}

# Entry point for commands dealing with directories.
multi sub MAIN(Command $command, Str $directory where *.IO.d) {
    given $command {
        when setup {
            writeStarterConfig($directory.IO);
            readConfig();
            defineDatabaseSchema();
            writeShellCompletion();
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }
}

# Entry point for commands dealing with files.
multi sub MAIN(Command $command, Str $file where *.IO.f) {
    given $command {
        when import {
            my $tagValue = readTag($file.IO, 'datecreated');
            if (!$tagValue) {
                my Str $answer = prompt "No date tag found. Still continue? [y/N]: ";
                unless ($answer eq "y") {
                    exit;
                }
            }

            my $destinationDir = %config<_><root>.IO.add($tagValue.subst(":", "/", :g));

            moveFile($file.IO, $destinationDir);
        }

        CATCH {
            when X::ImageArchive::FileExists {
                note colored($_.message, 'red bold');
                exit 1;
            }
        }
    }
}

# Entry point for commands dealing with files and keywords.
multi sub MAIN(Command $command, Str $file where *.IO.f, *@keywords) {
    given $command {
        when tag {
            testKeywords(@keywords);

            my %tags = keywordsToTags(@keywords);

            my @contexts = activeContexts(@keywords);

            testContexts(@contexts);

            testContextCoverage(@contexts, %tags);

            %tags.append(askQuestions());

            tagFile($file.IO, %tags);
        }

        default {
            die X::ImageArchive::BadCommand.new;
        }
    }

    CATCH {
        my @usualSuspects = (
            X::ImageArchive::BadCommand,
            X::ImageArchive::EmptyContext,
            X::ImageArchive::BadKeyword,
        );

        if ($_ ~~ any @usualSuspects) {
            note colored($_.message, 'red bold');
            exit 1;
        }

        when X::ImageArchive::MissingContext {
            note colored($_.message, 'red bold');
            $_.suggest();
            exit 1;
        }
    }
}

# Internal functions
# ------------------------------------------------------------------------

# List the contexts that have not been explicity disabled by a
# negation keyword.
sub activeContexts(@keywords) {
    my @keywordsWithoutNegation = @keywords.map({ $_.subst(/^no/, '')});
    (%config<contexts>.keys (-) @keywordsWithoutNegation).keys;
}

# Prompt for tag values that are unique to the image.
sub askQuestions() {
    my %answers;

    for %config<prompts>.sort(*.key) {
        my $answer = prompt "{$_.value}: ";
        $answer .= trim;
        next unless $answer;
        %answers{$_.key} = ($_.trim for $answer.split(','))
    }

    return %answers;
}

# Convert a comma-delimited list of values to a list.
sub commaSplit(Str $value) {
    $value.split(/ \s* \, \s* /);
}

# Determine the set of negation keywords for all known contexts.
# A negation keyword is the name of a context prefixed with "no".
sub contextNegationKeywords() {
    %config<contexts>.keys.map({ "no" ~ $_ });
}

# Define the SQLite database used for full-text search.
sub defineDatabaseSchema() {
    my $dbh = openDatabase();

    $dbh.execute(q:to/STATEMENT/);
    CREATE TABLE IF NOT EXISTS metadata (
        id INTEGER PRIMARY KEY,
        path TEXT,
        pairs TEXT
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE VIRTUAL TABLE IF NOT EXISTS fts USING fts5(
        pairs, content=metadata, content_rowid=id
    )
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadata_after_insert
    AFTER INSERT ON metadata
    BEGIN
    INSERT INTO fts(rowid, pairs) VALUES (new.id, new.pairs);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadata_after_delete
    AFTER DELETE ON metadata
    BEGIN
    INSERT INTO fts(fts, rowid, pairs) VALUES('delete', old.id, old.pairs);
    END
    STATEMENT

    $dbh.execute(q:to/STATEMENT/);
    CREATE TRIGGER IF NOT EXISTS metadta_after_update
    AFTER UPDATE ON metadata
    BEGIN
    INSERT INTO fts(fts, rowid, pairs) VALUES('delete', old.id, old.pairs);
    INSERT INTO fts(rowid, pairs) VALUES (new.id, new.pairs);
    END
    STATEMENT

    $dbh.dispose;
}

# Create a new UUID using external utilities.
sub generateId() {
    my @generators = </proc/sys/kernel/random/uuid /usr/bin/uuidgen>;

    for @generators -> $generator {
        next unless ($generator.IO.f);

        my $proc = run $generator, :out, :err;
        my $id = $proc.out.slurp(:close);

        if ($proc.exitcode == 0) {
            return chomp($id);
        }
    }

    die X::ImageArchive::UUID.new();
}

# Store a file's tags in a database.
sub indexFile(IO $file) {
    my $proc = run 'exiftool', $file.Str, :out, :err;
    my $tags = $proc.out.slurp(:close);
    my $err  = $proc.err.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
    }

    my $dbh = openDatabase();
    my $sth = $dbh.prepare(q:to/STATEMENT/);
    INSERT INTO metadata (path, pairs)
    VALUES (?, ?)
    STATEMENT

    $sth.execute($file.Str, $tags);
    $dbh.dispose;
}

# Find all known keywords for a given context.
sub keywordsInContext($context) {
    my @keywords;

    my @aliases = commaSplit(%config<contexts>{$context});

    for %config.kv -> $section, %members {
        next if $section ~~ any <_ aliases prompts contexts>;
        next unless %members.keys (&) @aliases;
        @keywords.push($section)
    }

    return @keywords;
}

# Gather the tags that correspond to the given keywords.
sub keywordsToTags(@keywords) {
    my %tags;

    for %config.kv -> $key, %values {
        %tags.append(%values) if $key ~~ any @keywords;
    }

    return %tags;
}

# Move a file to a subfolder under the archive root.
sub moveFile(IO $file, IO $parent) {
    unless ($parent ~~ :d) {
        $parent.mkdir();
    }

    my $destination = $parent.add($file.basename);

    if ($destination.IO ~~ :f) {
        die X::ImageArchive::FileExists.new(:path($destination));
    }

    move($file, $destination);

    $destination.IO.chmod(0o400);

    indexFile($destination);

    say "Imported {$file.basename} to {$destination}";
}

# Open a connection to the SQLite database.
#
# Caller is responsible for disposing of the returned handle.
sub openDatabase() {
    my $dbPath = %config<_><root>.IO.add("ia.db");
    return DBIish.connect("SQLite", database => $dbPath);
}

# Load the application configuration file.
sub readConfig() {
    %config = Config::INI::parse(slurp CONFIG_FILE);
}

# Extract a tag specified from a file.
sub readTag(IO $file, $tag) {
    my $formalTag = %config<aliases>{$tag} || $tag;

    my $proc = run <exiftool -s3 -n>, "-{$formalTag}", $file.Str, :out, :err;
    my $err = $proc.err.slurp(:close);
    my $out = $proc.out.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
    }

    return chomp($out);
}

# Apply one or more tags specified as keywords to a file.
sub tagFile(IO $file, %tags) {
    my $uuid = readTag($file.IO, 'id');

    unless ($uuid) {
        %tags<id> = generateId();
    }

    %tags<datetagged> = DateTime.now();

    my @commands = tagsToExiftool(%tags);

    my $proc = run 'exiftool', @commands, $file.Str, :out, :err;

    my $err = $proc.err.slurp(:close);
    my $out = $proc.out.slurp(:close);

    if ($proc.exitcode !== 0) {
        die X::ImageArchive::ExifToolIsDispleased.new(:err($err));
    }
}

# Convert a set of tag keywords to a list of arguments suitable exiftool.
sub tagsToExiftool(%tags) {
    my @commands;

    for %tags.keys -> $tag {
        my $formalTag = %config<aliases>{$tag};

        my $operator = "=";
        if (%tags{$tag} ~~ List) {
            for %tags{$tag}.list -> $value {
                $operator = ($value ~~ %tags{$tag}.first) ?? "=" !! "+=";
                @commands.push("-{$formalTag}{$operator}{$value}");
            }
        } else {
            @commands.push("-{$formalTag}{$operator}{%tags{$tag}}");
        }

    }

    return @commands;
}

# See if there are any contexts with no tags.
sub testContextCoverage(@contexts, %tags) {

    # zipwith meta operator
    # See https://rosettacode.org/wiki/Hash_from_two_arrays#Raku
    my %contexts = @contexts Z=> %config<contexts>{@contexts};

    my $bag = BagHash.new;

    for %contexts.kv -> $key, $values {
        my @tags = commaSplit($values);
        ($bag{$key}++ if @tags (&) %tags.keys);
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties.elems > 0) {
        die X::ImageArchive::MissingContext.new(:offenders($empties.keys));
    }

}

# See if there are contexts with no keywords.
sub testContexts(@contexts) {
    my $bag = BagHash.new;

    for @contexts -> $context {
        ($bag{$context}++ if keywordsInContext($context));
    }

    my Set $empties = @contexts (-) $bag.keys;

    if ($empties) {
        die X::ImageArchive::EmptyContext.new(:offenders($empties.keys));
    }
}

# Determine if the provided keywords are valid.
sub testKeywords(@keywords) {
    my $duds = @keywords (-) %config.keys (-) contextNegationKeywords();

    if ($duds) {
        die X::ImageArchive::BadKeyword.new(:offenders($duds));
    }
}

sub writeShellCompletion() {
    my $keywords = ($_ unless $_ ~~ any <_ aliases prompts contexts> for %config.keys).join(' ');

    given %*ENV<SHELL>.IO.basename {

        when "fish" {
            my $completionFile = $*HOME.add(".config/fish/completions/ia.fish");

            unless ($completionFile.parent.d) {
                mkdir($completionFile.parent);
            }

            spurt $completionFile, qq:to/END/;
            # This file was autogenerated by the ia utility.

            complete -c ia -l help --exclusive

            complete -c ia -n __fish_use_subcommand -a completion -d "Completion command" -f
            complete -c ia -n __fish_use_subcommand -a import     -d "Import command" -F
            complete -c ia -n __fish_use_subcommand -a setup      -d "Setup command"
            complete -c ia -n __fish_use_subcommand -a tag        -d "Tag command" -F

            # The setup command takes a directory as its argument.
            complete -c ia -n "__fish_seen_subcommand_from setup" -r -f --arguments "(__fish_complete_directories (commandline -ct) 'archive root')"

            # The import command takes one or more keywords as arguments.
            complete -c ia -n "__fish_seen_subcommand_from tag" -a "{$keywords}"
            END

            say "Wrote $completionFile"
        }

        default {
            note colored("Sorry, shell completion isn't available for your shell", "yellow bold");
        }
    }
}

# Create a config file based on a default template.
sub writeStarterConfig(IO::Path $root) {
    if CONFIG_FILE.f {
        say "The file {CONFIG_FILE} already exists, so it was left untouched.";
        return;
    }

    spurt CONFIG_FILE, qq:to/END/;
    ; This is the configuration file for image-archive (ia)
    ; It uses the INI file format.

    [_]
    ; Where the images are stored.
    root = {$root.absolute}

    ; Questions that should be asked during tagging. They are the opposite
    ; of keywords.
    ;
    ; Use this to gather tag information that varies from file to file.
    ; Keys are aliases and values are the question text.
    [prompts]
    datecreated = Date the picture was taked (YYYY-MM-DD or partial)
    caption     = Caption
    keyword     = Additional keywords
    series      = Series or batch
    seriesid    = ID within series

    ; Aliases for tag names.
    ;
    ; Since tag names are verbose and akward to type, map them to more friendly
    ; equivalents. Keys are the informal name and values are the formal counterpart.
    [aliases]
    caption     = XML-dc:description
    colormode   = XMP-photoshop:ColorMode
    datecreated = XMP-photoshop:DateCreated
    datetagged  = XMP-xmp:MetadataDate
    location    = XMP-iptcExt:LocationCreated
    model       = Model
    object      = ArtworkOrObject
    person      = XMP-iptcExt:PersonInImage
    keyword     = XMP-dc:subject
    scene       = XMP-iptcCore:Scene
    series      = XMP-iptcExt:SeriesName
    seriesid    = XMP-iptcExt:SeriesIdentifier
    sourcetype  = XMP-iptcExt:DigitalSourceType
    subjectcode = XMP-iptcCore:SubjectCode

    ; Contexts
    ;
    ; A context is a list of comma-separated tag aliases. They are a way to
    ; enforce comprehensive tagging by requiring at least one keyword from
    ; each list to be present.
    [contexts]
    location = location
    object = object
    people = person
    relationship = subjectcode
    scene = scene
    source = model, sourcetype, colormode

    ; Keywords
    ;
    ; The rest of this file defines tagging keywords. The keyword is the
    ; section name, the keys are aliases, and the values are what will be
    ; ulatimatley be written to the image.
    ;
    ;
    ; Keywords are for applying the same tag value to multiple files, both
    ; for convenience and consistency. They are the opposite of prompts.

    ;; Color mode keywords
    ;; See https://exiftool.org/TagNames/XMP.html#photoshop
    [blackandwhite]
    colormode = Grayscale

    [color]
    colormode = RGB

    ;; Source type keywords
    ;; See http://cv.iptc.org/newscodes/digitalsourcetype/
    [digital]
    sourcetype = digitalCapture

    [negative]
    sourcetype = negativeFilm

    [slide]
    sourcetype = positiveFilm
    keyword = slide

    [photo]
    sourcetype = print

    [software]
    sourcetype = softwareImage

    ;; Scene keywords
    ;; See http://cv.iptc.org/newscodes/scene
    [action]
    scene = 011900

    [aerialview]
    scene = 011200

    [closeup]
    scene = 011800

    [couple]
    scene = 010700

    [exteriorview]
    scene = 011600

    [fulllength]
    scene = 010300

    [generalview]
    scene = 011000

    [group]
    scene = 010900

    [halflength]
    scene = 010200

    [headshot]
    scene = 010100

    [interiorview]
    scene = 011700

    [nightscene]
    scene = 011400

    [offbeat]
    scene = 012300

    [panoramicview]
    scene = 011100

    [performing]
    scene = 012000

    [posing]
    scene = 012100

    [profile]
    scene = 010400

    [rearview]
    scene = 010500

    [satellite]
    scene = 011500

    [single]
    scene = 010600

    [symbolic]
    scene = 012200

    [two]
    scene = 010800

    [underwater]
    scene = 011300

    ; ---- End of the default keyword set ----

    END

    say "Default configuration written to {CONFIG_FILE}";
    say "Using {$root.absolute} as the archive root.";
}
