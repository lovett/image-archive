#!/usr/bin/env rakudo

use DBIish;
use Terminal::ANSIColor;

use ImageArchive::Archive;
use ImageArchive::Color;
use ImageArchive::Config;
use ImageArchive::Database;
use ImageArchive::Exception;
use ImageArchive::Shell;
use ImageArchive::Hints;
use ImageArchive::Tagging;
use ImageArchive::Util;
use ImageArchive::Workspace;

our Str constant SCRIPT_VERSION = "2021.02.18";

proto MAIN(|) {
    # Suppress backtrace. Taken from zef's CLI.pm6.
    CATCH {
        default {
            try { ::("Rakudo::Internals").?LL-EXCEPTION } ?? .rethrow !! note colored(.message, 'red'); &*EXIT(1)
        }
    }
    {*}
}

#| Generate alternate image sizes.
multi sub MAIN('alts', Bool :$dryrun) {
    generateAlts($dryrun);
}

#| Remove empty subdirectories in the archive.
multi sub MAIN('cleanup') {
    my $root = getPath('root');
    pruneEmptyDirsDownward($root);
}

#| The average color of a file.
multi sub MAIN('color', Str $file where *.IO.f) {
    my @rgb = getAverageColor($file.IO);
    printf("rgb(%s)\n", @rgb.join(','));
}

#| The average color of files using search indexes.
multi sub MAIN('color', Str $index) {
    my @records = findByStashIndex($index, 'AverageRGB'.List);

    for @records -> $record {
        printf(
            "%-16s | %s\n",
            "rgb({$record[1]})",
            relativePath($record[0])
        );
    }
}

#| Generate the shell completion file.
multi sub MAIN('completion') {
    writeShellCompletion(SCRIPT_VERSION);
}

#| The number of files overall.
multi sub MAIN('count') {
    my $fileCount = countFiles();
    my $recordCount = countRecords();

    say pluralize($fileCount, 'file', 'files');

    if ($recordCount ne $fileCount) {
        say pluralize($recordCount, 'database record', 'database records');

        say qq:to/END/;

        {colored('Fix', 'cyan underline')}
          {$*PROGRAM-NAME} reindex

        {colored('View', 'cyan underline')}
          {$*PROGRAM-NAME} search:unindexed
        END
    }
}

#| The number of files per year.
multi sub MAIN('count:years') {
    for countRecordsByYear() -> $tally {
        my $year = $tally[0];
        $year = 'Undated' if $year == 0;
        printf("%7s | %s\n", $year, $tally[1]);
    }
}

#| The number of files per month in a given year.
multi sub MAIN('count', Int $year) {
    for countRecordsByMonth($year) -> $tally {
        my $month = $tally[0] == 0 ?? 'Unknown' !! monthName($tally[0]);
        printf("%10s | %s\n", $month, $tally[1]);
    }
}

#| Start a database CLI session.
multi sub MAIN('dbshell') {
    my $dbPath = getPath('database');
    run 'sqlite3', $dbPath;
}

#| Taka a file out of the archive.
multi sub MAIN('deport', Str $file where *.IO.f, Bool :$dryrun) {
    my $root = getPath('root');
    my $target = findFile($file);

    deportFile($target, $*CWD.IO, $dryrun);

    my $workspace = findWorkspace($target);
    if ($workspace ~~ :d) {
        moveWorkspace($workspace, $*CWD.IO, $dryrun);
    }

    pruneEmptyDirsUpward($target.parent);
}

#| Take a file out of the archive using search indexes.
multi sub MAIN('deport', Str $index, Bool :$dryrun) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $file = findFile($record[0]);
        deportFile($file, $*CWD.IO, $dryrun);

        my $workspace = findWorkspace($file);
        if ($workspace ~~ :d) {
            moveWorkspace($workspace, $*CWD.IO, $dryrun);
        }

        pruneEmptyDirsUpward($file.parent);
    }
}

#| View an archive file's workspace history.
multi sub MAIN('history', Str $file where *.IO.f) {
    my $workspace = findWorkspace($file.IO);

    unless ($workspace ~~ :d) {
        die "No workspace found for this file."
    }

    my $log = findWorkspaceLog($workspace);

    unless ($log ~~ :f) {
        die "No log found.";
    }

    for $log.lines -> $line {
        next unless $line.trim;
        next if $line.starts-with('#');
        say $line.subst(/\*+\s/, "");
        print "\n" if $line.starts-with('*');
    }
    say "";
}

#| Bring a file into the archive.
multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    my $importedFile = importFile($file.IO, $dryrun);
    say "Imported as {$importedFile}";
}

#| Replace an archive file with a workspace file.
multi sub MAIN('promote', Str $file, Bool :$dryrun) {
    my $target = findFile($file);

    workspaceExport($target, $dryrun);

    my $workspace = $target.parent;
    closeWorkspace($workspace, $dryrun);

    CATCH {
        when ImageArchive::Exception::PathNotFoundInWorkspace {
            note colored($_.message, 'red');
            exit 1;
        }
    }
}

#| Re-add imported files to the database.
multi sub MAIN('reindex') {
    my $root = getPath('root');

    for walkArchive($root) -> $path {
        print "Reindexing {$path}...";
        # Don't add any new tags, but do add auto-generated ones.
        tagFile($path, {});
        indexFile($path);
        say "done.";
    }
}

#| Re-add imported files to the database using search index.
multi sub MAIN('reindex', Str $index) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $path = findFile($record[0]);
        print "Reindexing {$path}...";
        tagFile($path, {});
        indexFile($path);
        say "done.";
    }
}

#| Redo question-and-answer tagging.
multi sub MAIN('reprompt', Str $file where *.IO.f, Bool :$dryrun = False) {
    my %tags = askQuestions();
    tagFile($file.IO, %tags, $dryrun);

    return if $dryrun;

    if (isArchiveFile($file.IO)) {
        my $importedFile = importFile($file.IO);
        if ($importedFile) {
            say "Relocated to {$importedFile}";

            my $workspace = findWorkspace($file.IO);
            if ($workspace ~~ :d) {
                moveWorkspace($workspace, $importedFile.parent);
            }
            pruneEmptyDirsUpward($file.IO.parent);
        } else {
            indexFile($file.IO);
        }
    }
}

#| Redo question-and-answer tagging using search indexes.
multi sub MAIN('reprompt', Str $index, Bool :$dryrun = False) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $path = findFile($record[0]);
        my %tags = askQuestions();
        tagFile($path, %tags, $dryrun);

        return if $dryrun;

        my $importedFile = importFile($path);
        if ($importedFile) {
            say "Relocated to {$importedFile}";

            my $workspace = findWorkspace($path);
            if ($workspace ~~ :d) {
                moveWorkspace($workspace, $importedFile.parent);
            }
           pruneEmptyDirsUpward($path.parent);
        } else {
            indexFile($path);
        }
    }
}

#| Find files by tag.
multi sub MAIN('search', Bool :$debug = False, *@terms) {

    my $query = @terms.join(' ');

    my $counter = 0;
    for findByTag($query, $debug) -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $series = sprintf('%s-%03d', $result<series>, $result<seriesid>);

        printf(
            "%s | %15s | %s\n",
            colored($index, 'white on_blue'),
            $series,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }

    CATCH {
        when ImageArchive::Exception::BadFilter {
            note colored($_.message, 'red');
            suggestFilters();
            exit 1;
        }
    }
}

multi sub MAIN('search') is hidden-from-USAGE {
    die ImageArchive::Exception::NoSearchQuery.new;
}

#| Find files by color similarity.
multi sub MAIN('search:color', Str $file where *.IO.f) {
    my @rgb = getAverageColor($file.IO);

    my $counter = 0;
    for findBySimilarColor(@rgb) -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $score = sprintf("%2.2f", $result<score>);

        printf(
            "%s | %s | %s\n",
            colored($index, 'white on_blue'),
            $score,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }
}

#| Find file that are not in the database.
multi sub MAIN('search:unindexed') {
    my $counter = 0;

    for findUnindexed() -> $path {
        my $index = sprintf("%3d", ++$counter);
        printf(
            "%s | %s\n",
            colored($index, 'white on_red'),
            relativePath($path),
        );
    }

    unless $counter {
        say "No unindexed files.";
    }
}

#| Establish the application configuration and database.
multi sub MAIN('setup', Str $directory where *.IO.d) {
    writeApplicationConfig($directory.IO);

    writeArchiveConfig();

    createDatabase();

    writeShellCompletion(SCRIPT_VERSION);
}

#| Display a file's tags.
multi sub MAIN('show', Str $file where *.IO.f) {
    my %aliases = readConfig('aliases');

    say readTags($file.IO, %aliases.values);
}

#| Display tags using search indexes.
multi sub MAIN('show', $indexes) {
    my @records = findByStashIndex($indexes);

    my %aliases = readConfig('aliases');

    for @records -> $record {
        my $file = findFile($record[0]);
        say readTags($file, %aliases.values);
    }
}

#| Redisplay the results of the previous search.
multi sub MAIN('show:search') {
    my $counter = 0;
    for dumpStash() -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $series = sprintf('%s-%03d', $result<series>, $result<seriesid>);

        printf(
            "%s | %15s | %s\n",
            colored($index, 'white on_blue'),
            $series,
            $result<path>
        );
    }
}

#| Add tags to a file.
multi sub MAIN('tag', Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    testKeywords(@keywords);

    # If the file has id and alias tags, consider it previously tagged
    # and skip context validation.
    my $previouslyTagged = readRawTags($file.IO, ['id', 'alias']).elems == 2;

    my %tags = keywordsToTags(@keywords);

    unless ($previouslyTagged) {
        my @contexts = activeContexts(@keywords);

        testContexts(@contexts);

        testContextCoverage(@contexts, @keywords);

        %tags.append(askQuestions());
    }

    %tags<alias> = @keywords;

    tagFile($file.IO, %tags, $dryrun);

    if ($dryrun) {
        return;
    }

    if (isArchiveFile($file.IO)) {
        indexFile($file.IO);
        return;
    }

    confirm('Tags written. Import to archive?');
    my $importedFile = importFile($file.IO, $dryrun);
    say "Imported as {$importedFile}";

    CATCH {
        when ImageArchive::Exception::MissingContext {
            note colored($_.message, 'red');
            suggestContextKeywords($_.offenders);
            exit 1;
        }
    }
}

#| Add tags using search indexes.
multi sub MAIN('tag', Str $index, Bool :$dryrun = False, *@keywords) {
    my @records = findByStashIndex($index);

    my %tags = keywordsToTags(@keywords);

    for @records -> $record {
        my $path = findFile($record[0]);
        tagFile($path, %tags, $dryrun);

        unless ($dryrun) {
            indexFile($path);
        }
    }
}

#| Remove tags by alias or value.
multi sub MAIN('untag:alias', Str $file where *.IO.f, Str $alias, Str $value?, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $value, $dryrun);

    if (isArchiveFile($file.IO)) {
        indexFile($file.IO);
    }
}

#| Remove tags by alias or value using search indexes.
multi sub MAIN('untag:alias', Str $index, Str $alias, Str $value?, Bool :$dryrun = False) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $path = findFile($record[0]);
        untagAlias($path, $alias, $value, $dryrun);

        if (isArchiveFile($path)) {
            indexFile($path);
        }
    }
}

#| Remove tags by alias or value in all files.
multi sub MAIN('untag:alias', 'allfiles', Str $alias, Str $value?, Bool :$dryrun = False) {
    archiveUntagAlias($alias, $value, $dryrun);
}

#| Remove tags by keyword.
multi sub MAIN('untag:keyword', Str $file where *.IO.f, Str $keyword, Bool :$dryrun = False) {
    untagKeyword($file.IO, $keyword, $dryrun);
}

#| Remove tags by keyword using search indexes.
multi sub MAIN('untag:keyword', Str $index, Str $keyword, Bool :$dryrun = False) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $path = findFile($record[0]);
        untagKeyword($path, $keyword, $dryrun);

        if (isArchiveFile($path)) {
            indexFile($path);
        }
    }
}

#| Remove a tag by value in all files.
multi sub MAIN('untag:keyword', 'allfiles', Str $keyword, Bool :$dryrun = False) {
    archiveUntagKeyword($keyword, $dryrun);
}

#| Display a file using an alternate.
multi sub MAIN('view', Str $file where *.IO.f) {
    my @altSizes = readConfig('alt_sizes').split(' ');
    my $path = relativePath($file);
    my @targets = findAlternate($path, @altSizes.first);
    viewFiles(@targets);
}

#| Display one or more files by searchin index using altnerates.
multi sub MAIN('view', $index) {
    my @records = findByStashIndex($index);
    my @altSizes = readConfig('alt_sizes').split(' ');
    my @targets = @records.map({ findAlternate($_[0], @altSizes.first) });
    viewFiles(@targets);
}

#| Display an original file.
multi sub MAIN('view:original', Str $file where *.IO.f) {
    my @targets = findFile($file);
    viewFiles(@targets);
}

#| Display one or more originals by search index.
multi sub MAIN('view:original', $index) {
    my @records = findByStashIndex($index);
    my @targets = @records.map({ findFile($_[0]) });
    viewFiles(@targets);
}

#| Set up an editing workspace for the last imported file.
multi sub MAIN('workon', 'lastimport') {
    my @targets = findByNewestImport();

    unless @targets {
        die 'Nothing found.';
    }

    my $target = findFile(@targets.first<path>);

    copyToWorkspace($target);
    editWorkspaceLog($target);
}

#| Set up an editing workspace.
multi sub MAIN('workon', Str $file where *.IO.f) {
    my $target = findFile($file);

    copyToWorkspace($target.IO);

    editWorkspaceLog($target);
}

#| Set up an editing workspace by search index.
multi sub MAIN('workon', $index) {
    my @records = findByStashIndex($index);

    for @records -> $record {
        my $path = findFile($record[0]);
        copyToWorkspace($path.IO);
        editWorkspaceLog($path.IO);

    }
}

#| List workspaces.
multi sub MAIN('workspaces', Str $year?, Bool :$archived) {
    my $origin = getPath('root');
    if ($year) {
        $origin = findFile($year);
    }

    my $state = ($archived) ?? Closed !! Opened;

    my $counter = 0;
    for walkWorkspaces($origin, $state) -> $path {
        $counter++;
        say $path.Str;
    }

    if ($counter == 0) {
        say "None found.";
    }
}

#| Display the application version.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

sub USAGE() {
    if @*ARGS.elems == 2 && @*ARGS.first eq '--help' {
        my $command = @*ARGS[1];
        my $shortSummary = $*USAGE.lines.grep( / ' ' $command ' ' / ).first;

        if ($shortSummary) {
            say "Usage:";
            say $shortSummary;

            if ($command eq 'search') {
                say explainSearchSynax();
            }
            return;
        }


    }

    say $*USAGE;
}

# Local Variables:
# mode: raku
# End:
