#!/usr/bin/env rakudo

use Terminal::ANSIColor;

use ImageArchive::Activity;
use ImageArchive::Archive;
use ImageArchive::Color;
use ImageArchive::Config;
use ImageArchive::Database;
use ImageArchive::Exception;
use ImageArchive::Shell;
use ImageArchive::Hints;
use ImageArchive::Tagging;
use ImageArchive::Util;
use ImageArchive::Workspace;

#| Generate alternate image sizes.
multi sub MAIN('alts', Bool :$dryrun) {
    generateAlts($dryrun);
}

#| Remove empty subdirectories in the archive.
multi sub MAIN('cleanup') {
    pruneEmptyDirsDownward();
}

#| Display the average color of a file by path or search index.
multi sub MAIN('color', $target) {
    my %targets = resolveColorTarget($target);
    printColorTable(%targets);
}

#| Generate the shell completion file.
multi sub MAIN('completion') {
    writeShellCompletion();
}

#| The number of files overall.
multi sub MAIN('count') {
    countFiles();
}

#| The number of files per year.
multi sub MAIN('count:years') {
    countYears();
}

#| The number of files per month in a given year.
multi sub MAIN('count', Int $year) {
    countMonths($year);
}

#| Start a database CLI session.
multi sub MAIN('dbshell') {
    openDatabaseSession();
}

#| Take a file out of the archive.
multi sub MAIN('deport', Str $target, Bool :$dryrun) {
    my @targets = resolveFileTarget($target, 'original');
    deportFiles(@targets, $*CWD.IO, $dryrun);
}

#| Display a file's history log by path or search index.
multi sub MAIN('history', Str $target) {
    my @targets= resolveFileTarget($target, 'original');
    printHistory(@targets);
}

#| Bring a file into the archive.
multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    my $importedFile = importFile($file.IO, $dryrun);
    indexFile($importedFile);
    say "Imported as {$importedFile}";
}

#| Replace an archive file with a workspace file.
multi sub MAIN('promote', Str $file, Bool :$dryrun) {
    my $target = findFile($file);

    workspaceExport($target, $dryrun);

    CATCH {
        when ImageArchive::Exception::PathNotFoundInWorkspace {
            note colored($_.message, 'red');
            exit 1;
        }
    }
}

#| Re-add imported files to the database using search index.
multi sub MAIN('reindex', Str $target?) {
    reindex($target);
}

#| Redo question-and-answer tagging.
multi sub MAIN('reprompt', Str $target, Bool :$dryrun = False) {
    my @targets = resolveFileTarget($target, 'taggable');
    reprompt(@targets, $dryrun);
}

#| Find recently-imported files.
multi sub MAIN('search:recent', Int $limit = 10) {
    my @results = findNewest($limit, 'searchresult');
    printSearchResults(@results);
}

#| Find files by tag.
multi sub MAIN('search', Bool :$debug = False, *@terms) {
    my $query = @terms.join(' ');
    my @results = findByTag($query, 'searchresult', $debug);
    printSearchResults(@results);

    CATCH {
        when ImageArchive::Exception::BadFilter {
            note colored($_.message, 'red');
            suggestFilters();
            exit 1;
        }
    }
}

multi sub MAIN('search') is hidden-from-USAGE {
    die ImageArchive::Exception::NoSearchQuery.new;
}

#| Find files by color similarity.
multi sub MAIN('search:color', Str $file where *.IO.f) {
    my @rgb = getAverageColor($file.IO);

    my $counter = 0;
    for findBySimilarColor(@rgb, 'searchresult') -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $score = sprintf("%2.2f", $result<score>);

        printf(
            "%s | %s | %s\n",
            colored($index, 'white on_blue'),
            $score,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }
}

#| Find file that are not in the database.
multi sub MAIN('search:unindexed') {
    my $counter = 0;

    for findUnindexed() -> $path {
        my $index = sprintf("%3d", ++$counter);
        printf(
            "%s | %s\n",
            colored($index, 'white on_red'),
            relativePath($path),
        );
    }

    unless $counter {
        say "No unindexed files.";
    }
}

#| Establish the application configuration and database.
multi sub MAIN('setup', Str $directory where *.IO.d) {
    writeApplicationConfig($directory.IO);

    writeArchiveConfig();

    createDatabase();

    writeShellCompletion();
}

#| Display a file's tags.
multi sub MAIN('show', Str $target) {
    my @targets = resolveFileTarget($target, 'taggable');
    showTags(@targets);
}

#| Redisplay the results of the previous search.
multi sub MAIN('show:search') {
    my @results = dumpStash('searchresult');
    printSearchResults(@results);
}

#| Add tags to a file.
multi sub MAIN('tag', Str $target, Bool :$dryrun, *@keywords) {
    my @targets = resolveFileTarget($target, 'taggable');
    tagAndImport(@targets, @keywords, $dryrun);
}

#| List out TODO lines in workspace history files.
multi sub MAIN('todo', Str $directory?) {
    searchLogs(/TODO/, $directory);
}

#| Remove tags by alias or value.
multi sub MAIN('untag:alias', Str $target, Str $alias, Str $value?, Bool :$dryrun = False, ) {
    my @targets = resolveFileTarget($target, 'taggable');
    untagByAlias(@targets, $alias, $value, $dryrun);
}

#| Remove tags by alias or value in all files.
multi sub MAIN('untag:alias:allfiles', Str $alias, Str $value?, Bool :$dryrun = False) {
    archiveUntagAlias($alias, $value, $dryrun);
}

#| Remove tags by keyword.
multi sub MAIN('untag:keyword', Str $target, Str $keyword, Bool :$dryrun = False) {
    my @targets = resolveFileTarget($target, 'taggable');
    untagByKeyword(@targets, $keyword, $dryrun);
}

#| Remove a tag by value in all files.
multi sub MAIN('untag:keyword:allfiles', Str $keyword, Bool :$dryrun = False) {
    archiveUntagKeyword($keyword, $dryrun);
}

#| Display a file alternate by path or search index.
multi sub MAIN('view', Str $target) {
    my @targets = resolveFileTarget($target);
    viewFiles(@targets);
}

#| Display an original file by path or search index.
multi sub MAIN('view:original', Str $target) {
    my @targets = resolveFileTarget($target, 'original');
    viewFiles(@targets);
}

#| Navigate to an archive file by path or search index.
multi sub MAIN('visit', Str $target) {
    my @targets = resolveFileTarget($target, 'parent');
    viewDirectories(@targets);
}

#| Set up an editing workspace by path or search index.
multi sub MAIN('workon', $target) {
    my @targets = resolveFileTarget($target, 'original');
    my $workspace = copyToWorkspace(@targets.first);
    viewDirectories($workspace.list);
}

#| Display the application version.
multi sub MAIN(Bool :$version) {
    say applicationVersion() if $version;
}

sub USAGE() {
    if @*ARGS.elems == 2 && @*ARGS.first eq '--help' {
        my $command = @*ARGS[1];
        my $shortSummary = $*USAGE.lines.grep( / ' ' $command ' ' / ).first;

        if ($shortSummary) {
            say "Usage:";
            say $shortSummary;

            if ($command eq 'search') {
                say explainSearchSynax();
            }
            return;
        }


    }

    say $*USAGE;
}

# Local Variables:
# mode: raku
# End:
