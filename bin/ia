#!/usr/bin/env rakudo

use DBIish;
use Terminal::ANSIColor;

use ImageArchive::Archive;
use ImageArchive::Config;
use ImageArchive::Database;
use ImageArchive::Exception;
use ImageArchive::Shell;
use ImageArchive::Suggestion;
use ImageArchive::Tagging;
use ImageArchive::Util;
use ImageArchive::Workspace;

our Str constant SCRIPT_VERSION = "2020.11.03";

# Entry points
# ------------------------------------------------------------------------
proto MAIN(|) {
    # Suppress backtrace. Taken from zef's CLI.pm6.
    CATCH {
        default {
            try { ::("Rakudo::Internals").?LL-EXCEPTION } ?? .rethrow !! note colored(.message, 'red bold'); &*EXIT(1)
        }
    }
    {*}
}

#| Generate alternate image sizes.
multi sub MAIN('alts') {
    generateAlts();
}

#| Write the shell completion file.
multi sub MAIN('completion') {
    writeShellCompletion(SCRIPT_VERSION);
}

#| Number of files per year.
multi sub MAIN('count', 'years') {
    my $undated = 0;

    for countRecordsByYear() -> $tally {
        if ($tally[0]) {
            sprintf("%10s: %4d", $tally[0], $tally[1]).say;
            next;
        }

        $undated = $tally[1];
    }

    say sprintf("%10s: %4d", 'Undated',  $undated);
}

#| Number of files in a given year per month.
multi sub MAIN('count', Int $year) {
    my $unknown = 0;

    for countRecordsByMonth($year.Int) -> $tally {
        if ($tally[0]) {
            sprintf("%10s: %s", monthName($tally[0]), $tally[1]).say;
            next;
        }

        $unknown = $tally[1];
    }

    say sprintf("%10s: %s", 'Unknown', $unknown);
}

#| Start a database CLI session.
multi sub MAIN('dbshell') {
    my $dbPath = getPath('database');
    run 'sqlite3', $dbPath;
}

#| Move a file out of the archive.
multi sub MAIN('deport', Str $file, Bool :$dryrun) {
    my $target;

    if ($file.IO ~~ :f) {
        $target = $file.IO;
    } else {
        my $root = getPath('root');
        $target = $root.add($file);
    }

    testPathExistsInArchive($target);
    deportFile($target, $*CWD.IO, $dryrun);

    my $workspace = findWorkspace($target);
    if ($workspace ~~ :d) {
        deportWorkspace($workspace, $*CWD.IO, $dryrun);
    }
}

#| Display a file's tags.
multi sub MAIN('dump', Str $file where *.IO.f, *@aliases) {
    my %prompts = readConfig('prompts');
    unless @aliases.elems > 0 {
        @aliases = ['alias'].append: %prompts.keys;
    }

    my %tags = readRawTags($file.IO, @aliases, '-f');

    for %tags.kv -> $alias, $value {
        say "{$alias}: {$value}";
    }
}

#| Bring a file into the archive.
multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    importFile($file.IO, $dryrun);
}

#| Replace an archive file with a new version.
multi sub MAIN('promote', $file where *.IO.f, Bool :$dryrun) {
    workspaceExport($file.IO, $dryrun);

    CATCH {
        when ImageArchive::Exception::PathNotFoundInWorkspace {
            note colored($_.message, 'red bold');
            exit 1;
        }
    }
}

#| Re-index files already in the archive.
multi sub MAIN('reimport') {
    my $root = getPath('root');

    for walkArchive($root) -> $path {
        indexFile($path);
        say "Reindexed {$path}";
    }
}

#| Do-over for question-and-answer tagging.
multi sub MAIN('reprompt', Str $file where *.IO.f, Bool :$dryrun = False) {
    my %tags = askQuestions();
    tagFile($file.IO, %tags, $dryrun);
}

#| Find images in the archive by their tags.
multi sub MAIN('search', *@terms) {
    my $query = @terms.join(' ');

    my $counter = 0;
    for searchMetadata($query) -> $result {
        my $index = colored(sprintf("%3d", ++$counter), 'cyan');
        say " $index $result";
    }

    unless ($counter) {
        note 'No matches.';
    }

    CATCH {
        when ImageArchive::Exception::BadFilter {
            note colored($_.message, 'red bold');
            suggestFilters();
            exit 1;
        }
    }
}

multi sub MAIN('search') is hidden-from-USAGE {
    die ImageArchive::Exception::NoSearchQuery.new;
}

#| Establish the application's configuration and database.
multi sub MAIN('setup', Str $directory where *.IO.d) {
    writeApplicationConfig($directory.IO);

    writeArchiveConfig();

    applyDatabaseSchema();

    writeShellCompletion(SCRIPT_VERSION);
}

#| The size of the archive.
multi sub MAIN('count') {
    my $root = getPath('root');

    my $fileCount = 0;
    for walkArchive($root) -> $path {
        $fileCount++;
    }

    my $recordCount = countRecords();

    sprintf('%s in the database.', pluralize($recordCount, 'record', 'records')).say;

    if ($recordCount ne $fileCount) {
        sprintf('%s files in the archive.', pluralize($fileCount, 'file', 'files')).say;

        say '';
        say(colored('Suggestion:', 'yellow') ~ ' run reimport');
        say '';
    }
}

#| Annotate a file with metadata.
multi sub MAIN('tag', Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    testKeywords(@keywords);

    # If the file has id and alias tags, consider it previously tagged
    # and skip context validation.
    my $previouslyTagged = readRawTags($file.IO, ['id', 'alias']).elems == 2;

    my %tags = keywordsToTags(@keywords);

    unless ($previouslyTagged) {
        my @contexts = activeContexts(@keywords);

        testContexts(@contexts);

        testContextCoverage(@contexts, @keywords);

        %tags.append(askQuestions());
    }

    %tags<alias> = @keywords;

    tagFile($file.IO, %tags, $dryrun);

    unless ($dryrun) {
        confirm('Tags written. Import to archive?');
        importFile($file.IO, $dryrun);
    }

    CATCH {
        when ImageArchive::Exception::MissingContext {
            note colored($_.message, 'red bold');
            suggestContextKeywords($_.offenders);
            exit 1;
        }
    }
}

#| Remove a tag completely.
multi sub MAIN('untag:alias', Str $file where *.IO.f, Str $alias, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $dryrun);
}

#| Remove tags via keyword.
multi sub MAIN('untag:keyword', Str $file where *.IO.f, Str $keyword, Bool :$dryrun = False) {
    untagKeyword($file.IO, $keyword, $dryrun);
}

#| Remove a value from a tag.
multi sub MAIN('untag:value', Str $file where *.IO.f, Str $alias, Str $value, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $value, $dryrun);
}

#| Make an editable copy of a file in the archive.
multi sub MAIN('version', $file where *.IO.f) {
    testPathExistsInArchive($file.IO);

    my $version = workspaceImport($file.IO);

    say "The workspace is: " ~ colored($version.parent.Str, 'cyan');
    say "The version is: " ~ colored($version.Str, 'yellow');

    my $viewCommand = readConfig('view_workspace');

    if ($viewCommand) {
        openWorkspace($file.IO, $viewCommand);
    }
}

#| Display a single file.
multi sub MAIN('view', Str $file where *.IO.f) {
    viewFiles($file.list);
}

#| Display files from the previous search by number.
multi sub MAIN('view', *@indexes) {
    my @archivePaths = findBySearchIndex(@indexes.join(' '));

    unless (@archivePaths) {
        die 'No files found.';
    }

    my @absolutePaths = @archivePaths.map({ absolutePath $_ });
    viewFiles(@absolutePaths);
}

#| Display version information.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}
