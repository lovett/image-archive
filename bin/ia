#!/usr/bin/env rakudo

use DBIish;
use Terminal::ANSIColor;

use ImageArchive::Archive;
use ImageArchive::Config;
use ImageArchive::Database;
use ImageArchive::Exception;
use ImageArchive::Shell;
use ImageArchive::Hints;
use ImageArchive::Tagging;
use ImageArchive::Util;
use ImageArchive::Workspace;

our Str constant SCRIPT_VERSION = "2020.11.08";

# Entry points
# ------------------------------------------------------------------------
proto MAIN(|) {
    # Suppress backtrace. Taken from zef's CLI.pm6.
    CATCH {
        default {
            try { ::("Rakudo::Internals").?LL-EXCEPTION } ?? .rethrow !! note colored(.message, 'red'); &*EXIT(1)
        }
    }
    {*}
}

#| Generate alternate image sizes.
multi sub MAIN('alts') {
    generateAlts();
}

#| Generate the shell completion file.
multi sub MAIN('completion') {
    writeShellCompletion(SCRIPT_VERSION);
}

#| The number of files in the archive.
multi sub MAIN('count') {
    my $root = getPath('root');

    my $fileCount = 0;
    for walkArchive($root) -> $path {
        $fileCount++;
    }

    my $recordCount = countRecords();

    sprintf('%s in the database.', pluralize($recordCount, 'record', 'records')).say;

    if ($recordCount ne $fileCount) {
        sprintf('%s files in the archive.', pluralize($fileCount, 'file', 'files')).say;

        say '';
        say(colored('To fix:', 'green') ~ ' run reindex');
        say '';
    }
}

#| The number of files per year.
multi sub MAIN('count', 'years') {
    my $undated = 0;

    for countRecordsByYear() -> $tally {
        if ($tally[0]) {
            sprintf("%10s: %4d", $tally[0], $tally[1]).say;
            next;
        }

        $undated = $tally[1];
    }

    say sprintf("%10s: %4d", 'Undated',  $undated);
}

#| The number of files in a given year per month.
multi sub MAIN('count', Int $year) {
    my $unknown = 0;

    for countRecordsByMonth($year.Int) -> $tally {
        if ($tally[0]) {
            sprintf("%10s: %s", monthName($tally[0]), $tally[1]).say;
            next;
        }

        $unknown = $tally[1];
    }

    say sprintf("%10s: %s", 'Unknown', $unknown);
}

#| Start a database CLI session.
multi sub MAIN('dbshell') {
    my $dbPath = getPath('database');
    run 'sqlite3', $dbPath;
}

#| Move a file out of the archive.
multi sub MAIN('deport', Str $path, Bool :$dryrun) {
    my $target = findFile($path);

    deportFile($target, $*CWD.IO, $dryrun);

    my $workspace = findWorkspace($target);
    if ($workspace ~~ :d) {
        deportWorkspace($workspace, $*CWD.IO, $dryrun);
    }
}

#| Display a file's tags.
multi sub MAIN('dump', Str $file where *.IO.f, *@aliases) {
    my %prompts = readConfig('prompts');
    unless @aliases.elems > 0 {
        @aliases = ['alias'].append: %prompts.keys;
    }

    my %tags = readRawTags($file.IO, @aliases, '-f');

    for %tags.kv -> $alias, $value {
        say "{$alias}: {$value}";
    }
}

#| Bring a file into the archive.
multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    importFile($file.IO, $dryrun);
}

#| Replace an archive file with a new version.
multi sub MAIN('promote', Str $path, Bool :$dryrun) {
    my $target = findFile($path);

    workspaceExport($target, $dryrun);

    CATCH {
        when ImageArchive::Exception::PathNotFoundInWorkspace {
            note colored($_.message, 'red');
            exit 1;
        }
    }
}

#| Re-add imported files to the database.
multi sub MAIN('reindex') {
    my $root = getPath('root');

    for walkArchive($root) -> $path {
        # Don't add any new tags, but do add auto-generated ones.
        tagFile($path, {});
        indexFile($path);
        say "Reindexed {$path}";
    }
}

#| Do-over for question-and-answer tagging.
multi sub MAIN('reprompt', Str $file where *.IO.f, Bool :$dryrun = False) {
    my %tags = askQuestions();
    tagFile($file.IO, %tags, $dryrun);
}

#| Find images in the archive by their tags.
multi sub MAIN('search', Bool :$debug = False, *@terms) {

    my $query = @terms.join(' ');

    my $counter = 0;
    for searchMetadata($query, $debug) -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $series = sprintf('%s-%03d', $result<series>, $result<seriesid>);

        printf(
            "%s | %15s | %s\n",
            colored($index, 'white on_blue'),
            $series,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }

    CATCH {
        when ImageArchive::Exception::BadFilter {
            note colored($_.message, 'red');
            suggestFilters();
            exit 1;
        }
    }
}

multi sub MAIN('search') is hidden-from-USAGE {
    die ImageArchive::Exception::NoSearchQuery.new;
}

#| Establish the application's configuration and database.
multi sub MAIN('setup', Str $directory where *.IO.d) {
    writeApplicationConfig($directory.IO);

    writeArchiveConfig();

    applyDatabaseSchema();

    writeShellCompletion(SCRIPT_VERSION);
}

#| Annotate a file with metadata.
multi sub MAIN('tag', Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    testKeywords(@keywords);

    # If the file has id and alias tags, consider it previously tagged
    # and skip context validation.
    my $previouslyTagged = readRawTags($file.IO, ['id', 'alias']).elems == 2;

    my %tags = keywordsToTags(@keywords);

    unless ($previouslyTagged) {
        my @contexts = activeContexts(@keywords);

        testContexts(@contexts);

        testContextCoverage(@contexts, @keywords);

        %tags.append(askQuestions());
    }

    %tags<alias> = @keywords;

    tagFile($file.IO, %tags, $dryrun);

    unless ($dryrun) {
        confirm('Tags written. Import to archive?');
        importFile($file.IO, $dryrun);
    }

    CATCH {
        when ImageArchive::Exception::MissingContext {
            note colored($_.message, 'red');
            suggestContextKeywords($_.offenders);
            exit 1;
        }
    }
}

#| Remove a tag completely.
multi sub MAIN('untag:alias', Str $file where *.IO.f, Str $alias, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $dryrun);
}

#| Remove tags via keyword.
multi sub MAIN('untag:keyword', Str $file where *.IO.f, Str $keyword, Bool :$dryrun = False) {
    untagKeyword($file.IO, $keyword, $dryrun);
}

#| Remove a value from a tag.
multi sub MAIN('untag:value', Str $file where *.IO.f, Str $alias, Str $value, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $value, $dryrun);
}

#| Make an editable copy of a file in the archive.
multi sub MAIN('version', Str $path) {
    my $target = findFile($path);

    my $version = workspaceImport($target.IO);

    say sprintf('%s %s', colored('Workspace:', 'magenta'), $version.parent.Str);
    say sprintf('%s %S', colored('Version:', 'magenta'), $version.Str);

    my $viewCommand = readConfig('view_workspace');

    if ($viewCommand) {
        openWorkspace($target, $viewCommand);
    }
}

#| Open files in an external application.
multi sub MAIN('view', *@paths) {
    my @targets = findBySearchIndex(@paths.join(' '));

    unless (@targets.first) {
        @targets = @paths;
    }

    @paths = @targets.map({ findFile $_ });
    viewFiles(@paths);
}

#| Display the application version.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

sub USAGE() {
    if @*ARGS.elems == 2 && @*ARGS.first eq '--help' {
        my $command = @*ARGS[1];
        my $shortSummary = $*USAGE.lines.grep( / ' ' $command ' ' / ).first;

        if ($shortSummary) {
            say "Usage:";
            say $shortSummary;

            if ($command eq 'search') {
                say explainSearchSynax();
            }
            return;
        }


    }

    say $*USAGE;
}
