#!/usr/bin/env rakudo

use DBIish;
use Terminal::ANSIColor;

use ImageArchive::Archive;
use ImageArchive::Color;
use ImageArchive::Config;
use ImageArchive::Database;
use ImageArchive::Exception;
use ImageArchive::Shell;
use ImageArchive::Hints;
use ImageArchive::Tagging;
use ImageArchive::Util;
use ImageArchive::Workspace;

our Str constant SCRIPT_VERSION = "2020.11.13";

proto MAIN(|) {
    # Suppress backtrace. Taken from zef's CLI.pm6.
    CATCH {
        default {
            try { ::("Rakudo::Internals").?LL-EXCEPTION } ?? .rethrow !! note colored(.message, 'red'); &*EXIT(1)
        }
    }
    {*}
}

#| Generate alternate image sizes.
multi sub MAIN('alts', Bool :$dryrun) {
    generateAlts($dryrun);
}

#| Find the average color of a file.
multi sub MAIN('color', Str $file where *.IO.f) {
    my @rgb = getAverageColor($file.IO);
    printf("rgb(%s)\n", @rgb.join(','));
}

#| Generate the shell completion file.
multi sub MAIN('completion') {
    writeShellCompletion(SCRIPT_VERSION);
}

#| The number of files in the archive.
multi sub MAIN('count') {
    my $fileCount = countFiles();
    my $recordCount = countRecords();

    say pluralize($fileCount, 'file', 'files');

    if ($recordCount ne $fileCount) {
        say pluralize($recordCount, 'database record', 'database records');

        say qq:to/END/;

        {colored('Fix', 'cyan underline')}
          {$*PROGRAM-NAME} reindex

        {colored('View', 'cyan underline')}
          {$*PROGRAM-NAME} search:unindexed
        END
    }
}

#| The number of files per year.
multi sub MAIN('count:years') {
    for countRecordsByYear() -> $tally {
        my $year = $tally[0];
        $year = 'Undated' if $year == 0;
        printf("%7s | %s\n", $year, $tally[1]);
    }
}

#| The number of files per month in a given year.
multi sub MAIN('count', Int $year) {
    for countRecordsByMonth($year) -> $tally {
        my $month = $tally[0] == 0 ?? 'Unknown' !! monthName($tally[0]);
        printf("%10s | %s\n", $month, $tally[1]);
    }
}

#| Start a database CLI session.
multi sub MAIN('dbshell') {
    my $dbPath = getPath('database');
    run 'sqlite3', $dbPath;
}

#| Move a file out of the archive.
multi sub MAIN('deport', Str $path, Bool :$dryrun) {
    my $target = findFile($path);

    deportFile($target, $*CWD.IO, $dryrun);

    my $workspace = findWorkspace($target);
    if ($workspace ~~ :d) {
        deportWorkspace($workspace, $*CWD.IO, $dryrun);
    }
}

#| Bring a file into the archive.
multi sub MAIN('import', Str $file where *.IO.f, Bool :$dryrun) {
    importFile($file.IO, $dryrun);
}

#| Replace an archive file with a workspace file.
multi sub MAIN('promote', Str $path, Bool :$dryrun) {
    my $target = findFile($path);

    workspaceExport($target, $dryrun);

    CATCH {
        when ImageArchive::Exception::PathNotFoundInWorkspace {
            note colored($_.message, 'red');
            exit 1;
        }
    }
}

#| Re-add imported files to the database.
multi sub MAIN('reindex') {
    my $root = getPath('root');

    for walkArchive($root) -> $path {
        print "Reindexing {$path}...";
        # Don't add any new tags, but do add auto-generated ones.
        tagFile($path, {});
        indexFile($path);
        say "done.";
    }
}

#| Do-over for question-and-answer tagging.
multi sub MAIN('reprompt', Str $file where *.IO.f, Bool :$dryrun = False) {
    my %tags = askQuestions();
    tagFile($file.IO, %tags, $dryrun);
}

#| Find images in the archive by tag.
multi sub MAIN('search', Bool :$debug = False, *@terms) {

    my $query = @terms.join(' ');

    my $counter = 0;
    for findByTag($query, $debug) -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $series = sprintf('%s-%03d', $result<series>, $result<seriesid>);

        printf(
            "%s | %15s | %s\n",
            colored($index, 'white on_blue'),
            $series,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }

    CATCH {
        when ImageArchive::Exception::BadFilter {
            note colored($_.message, 'red');
            suggestFilters();
            exit 1;
        }
    }
}

multi sub MAIN('search') is hidden-from-USAGE {
    die ImageArchive::Exception::NoSearchQuery.new;
}

#| Find images in the archive by color similarity.
multi sub MAIN('search:color', Str $file where *.IO.f) {
    my @rgb = getAverageColor($file.IO);

    my $counter = 0;
    for findBySimilarColor(@rgb) -> $result {
        my $index = sprintf("%3d", ++$counter);
        my $score = sprintf("%2.2f", $result<score>);

        printf(
            "%s | %s | %s\n",
            colored($index, 'white on_blue'),
            $score,
            $result<path>
        );
    }

    unless ($counter) {
        note 'No matches.';
    }
}

#| Files in the archive that are not in the database.
multi sub MAIN('search:unindexed') {
    my $counter = 0;

    for findUnindexed() -> $path {
        my $index = sprintf("%3d", ++$counter);
        printf(
            "%s | %s\n",
            colored($index, 'white on_red'),
            relativePath($path),
        );
    }

    unless $counter {
        say "No unindexed files.";
    }
}

#| Establish the application's configuration and database.
multi sub MAIN('setup', Str $directory where *.IO.d) {
    writeApplicationConfig($directory.IO);

    writeArchiveConfig();

    createDatabase();

    writeShellCompletion(SCRIPT_VERSION);

    addWorkspaceShortcuts();
}

#| Display a file's tags.
multi sub MAIN('show', Str $file where *.IO.f) {
    say readTags($file.IO);
}

#| Annotate a file with metadata.
multi sub MAIN('tag', Str $file where *.IO.f, Bool :$dryrun = False, *@keywords) {
    testKeywords(@keywords);

    # If the file has id and alias tags, consider it previously tagged
    # and skip context validation.
    my $previouslyTagged = readRawTags($file.IO, ['id', 'alias']).elems == 2;

    my %tags = keywordsToTags(@keywords);

    unless ($previouslyTagged) {
        my @contexts = activeContexts(@keywords);

        testContexts(@contexts);

        testContextCoverage(@contexts, @keywords);

        %tags.append(askQuestions());
    }

    %tags<alias> = @keywords;

    tagFile($file.IO, %tags, $dryrun);

    unless ($dryrun) {
        confirm('Tags written. Import to archive?');
        importFile($file.IO, $dryrun);
    }

    CATCH {
        when ImageArchive::Exception::MissingContext {
            note colored($_.message, 'red');
            suggestContextKeywords($_.offenders);
            exit 1;
        }
    }
}

#| Remove a tag by alias.
multi sub MAIN('untag:alias', Str $file where *.IO.f, Str $alias, Bool :$dryrun = False, ) {
    untagAlias($file.IO, $alias, $dryrun);
}

#| Remove tags by keyword.
multi sub MAIN('untag:keyword', Str $file where *.IO.f, Str $keyword, Bool :$dryrun = False) {
    untagKeyword($file.IO, $keyword, $dryrun);
}

#| Remove a tag by value in one file.
multi sub MAIN('untag:value', Str $file where *.IO.f, Str $alias, Str $value, Bool :$dryrun = False) {
    untagValue($file.IO, $alias, $value, $dryrun);
}

#| Remove a tag by value in all files.
multi sub MAIN('untag:value', 'allfiles', Str $alias, Str $value, Bool :$dryrun = False) {
    archiveUntagValue($alias, $value, $dryrun);
}

#| Display files in an external application.
multi sub MAIN('view', Bool :$debug = False, *@paths) {
    my @targets = findByStashIndex(@paths.join(' '), $debug);

    unless (@targets.first) {
        @targets = @paths;
    }

    @paths = @targets.map({ findFile $_ });
    viewFiles(@paths);
}

#| Set up an editing workspace.
multi sub MAIN('workon', Str $path) {
    my $target = findFile($path);

    my $version = copyToWorkspace($target.IO);

    say sprintf('%s %s', colored('Workspace:', 'magenta'), $version.parent.Str);

    my $viewCommand = readConfig('view_workspace');

    if ($viewCommand) {
        openWorkspace($target, $viewCommand);
    }
}

#| Display the application version.
multi sub MAIN(Bool :$version) {
    say SCRIPT_VERSION if $version;
}

sub USAGE() {
    if @*ARGS.elems == 2 && @*ARGS.first eq '--help' {
        my $command = @*ARGS[1];
        my $shortSummary = $*USAGE.lines.grep( / ' ' $command ' ' / ).first;

        if ($shortSummary) {
            say "Usage:";
            say $shortSummary;

            if ($command eq 'search') {
                say explainSearchSynax();
            }
            return;
        }


    }

    say $*USAGE;
}

# Local Variables:
# mode: raku
# End:
